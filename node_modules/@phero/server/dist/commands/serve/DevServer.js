"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const core_1 = require("@phero/core");
const dev_1 = require("@phero/dev");
const crypto_1 = __importDefault(require("crypto"));
const fs_1 = require("fs");
const http_1 = __importDefault(require("http"));
const path_1 = __importDefault(require("path"));
const WatchProgram_1 = __importDefault(require("./WatchProgram"));
class DevServer {
    constructor(command, projectPath) {
        this.routes = {};
        this.requestIndex = 0;
        this.command = command;
        this.projectPath = projectPath;
        this.eventEmitter = new dev_1.ServerDevEventEmitter();
    }
    async start() {
        try {
            this.eventEmitter.emit({ type: "SERVE_INIT" });
            const server = await this.startHttpServer();
            this.eventEmitter.emit({ type: "SERVE_READY" });
            const program = this.startWatch();
        }
        catch (error) {
            if ((0, core_1.hasErrorCode)(error) && error.code === "EADDRINUSE") {
                throw new core_1.PortInUseError(this.command.port);
            }
            else {
                throw error;
            }
        }
    }
    get manifestPath() {
        return path_1.default.join(this.projectPath, "phero-manifest.d.ts");
    }
    // TODO should find the output path based on tsconfig
    get pheroExecutionJS() {
        return path_1.default.join(this.projectPath, "dist", "phero-execution.js");
    }
    startWatch() {
        // Start code watch
        const program = new WatchProgram_1.default(this.projectPath, this.buildProjectStart.bind(this), this.buildProjectSuccess.bind(this), this.buildProjectFailed.bind(this));
        program.start();
        return program;
    }
    startHttpServer() {
        return new Promise((resolve, reject) => {
            const server = http_1.default.createServer();
            server
                .on("request", this.requestHandler.bind(this))
                .on("listening", () => resolve(server))
                .on("error", (error) => reject(error))
                .listen(this.command.port);
        });
    }
    buildProjectStart() {
        this.eventEmitter.emit({ type: "BUILD_PROJECT_START" });
    }
    async buildProjectSuccess(pheroSourceFile, typeChecker) {
        this.eventEmitter.emit({ type: "BUILD_PROJECT_SUCCESS" });
        let app;
        try {
            this.eventEmitter.emit({ type: "BUILD_MANIFEST_START" });
            app = (0, core_1.parsePheroApp)(pheroSourceFile, typeChecker);
            const dts = (0, core_1.generateAppDeclarationFile)(app, typeChecker);
            await fs_1.promises.writeFile(this.manifestPath, dts);
            this.eventEmitter.emit({ type: "BUILD_MANIFEST_SUCCESS" });
        }
        catch (error) {
            this.eventEmitter.emit({
                type: "BUILD_MANIFEST_FAILED",
                errorMessage: error instanceof Error
                    ? `${error.message}\nIf you think this is a bug, please submit an issue here: https://github.com/phero-hq/phero/issues`
                    : "Unknown error",
            });
            return;
        }
        try {
            this.eventEmitter.emit({ type: "BUILD_RPCS_START" });
            this.routes = this.generateRoutes(app);
            const output = (0, core_1.generateRPCProxy)(app, typeChecker);
            await fs_1.promises.writeFile(this.pheroExecutionJS, output.js);
            this.clearRequireCache();
            this.eventEmitter.emit({ type: "BUILD_RPCS_SUCCESS" });
        }
        catch (error) {
            this.eventEmitter.emit({
                type: "BUILD_RPCS_FAILED",
                errorMessage: error instanceof Error ? error.message : "Unknown error",
            });
            return;
        }
    }
    buildProjectFailed(errorMessage) {
        this.eventEmitter.emit({
            type: "BUILD_PROJECT_FAILED",
            errorMessage,
        });
    }
    async requestHandler(req, res) {
        if (!req.url) {
            throw new Error("No url in request");
        }
        this.requestIndex = this.requestIndex + 1;
        const requestId = `${this.requestIndex}`;
        res.setHeader("Access-Control-Allow-Origin", "*");
        res.setHeader("Access-Control-Allow-Methods", "POST");
        res.setHeader("Access-Control-Allow-Headers", "content-type");
        const startTime = Date.now();
        if (req.method === "OPTIONS") {
            res.statusCode = 200;
            res.end();
            return;
        }
        if (this.eventEmitter.shouldRegisterListener(req)) {
            return this.eventEmitter.registerListener(res);
        }
        if (req.method === "GET") {
            if (req.url === "/manifest") {
                res.statusCode = 200;
                res.write(await fs_1.promises.readFile(this.manifestPath, "utf-8"));
                res.end();
                return;
            }
        }
        this.eventEmitter.emit({
            type: "RPC_START",
            url: req.url,
            requestId,
            dateTime: new Date().toISOString(),
        });
        if (req.method === "POST") {
            res.setHeader("Content-Type", "application/json");
            if (req.url) {
                const route = this.routes[req.url];
                if (route) {
                    try {
                        const { headers } = req;
                        const body = await readBody(req);
                        const rpcResult = await route({ headers, body });
                        res.statusCode = rpcResult.status;
                        if (rpcResult.status === 200) {
                            if (rpcResult.result === undefined) {
                                res.statusCode = 204;
                            }
                            else {
                                res.write(JSON.stringify(rpcResult.result));
                            }
                            this.eventEmitter.emit({
                                type: "RPC_SUCCESS",
                                url: req.url,
                                ms: Date.now() - startTime,
                                requestId,
                                dateTime: new Date().toISOString(),
                            });
                        }
                        else if (rpcResult.status === 400) {
                            // Validation error(s)
                            res.write(JSON.stringify(rpcResult.errors, null, 4));
                            this.eventEmitter.emit({
                                type: "RPC_FAILED_VALIDATION_ERROR",
                                url: req.url,
                                ms: Date.now() - startTime,
                                requestId,
                                dateTime: new Date().toISOString(),
                                errors: rpcResult.errors,
                                input: rpcResult.input,
                            });
                        }
                        else if (rpcResult.status === 500) {
                            // Error is thrown
                            res.write(JSON.stringify(rpcResult.error));
                            this.eventEmitter.emit({
                                type: "RPC_FAILED_FUNCTION_ERROR",
                                url: req.url,
                                ms: Date.now() - startTime,
                                requestId,
                                dateTime: new Date().toISOString(),
                                error: rpcResult.error,
                            });
                        }
                        else {
                            throw new Error("Unsupported http status");
                        }
                    }
                    catch (e) {
                        // Indicates a bug in Phero
                        res.statusCode = 500;
                        res.write(JSON.stringify({
                            errorMessage: e instanceof Error ? e.message : "Unknown error",
                        }));
                        this.eventEmitter.emit({
                            type: "RPC_FAILED_SERVER_ERROR",
                            url: req.url,
                            ms: Date.now() - startTime,
                            requestId,
                            dateTime: new Date().toISOString(),
                            error: {
                                message: e instanceof Error ? e.message : "Unknown error",
                                stack: (e instanceof Error && e.stack) || "",
                            },
                        });
                    }
                    finally {
                        res.end();
                        return;
                    }
                }
            }
        }
        res.statusCode = 404;
        res.write(`{ "error": "RPC not found" }`);
        res.end();
        this.eventEmitter.emit({
            type: "RPC_FAILED_NOT_FOUND_ERROR",
            url: req.url,
            ms: Date.now() - startTime,
            requestId,
            dateTime: new Date().toISOString(),
        });
    }
    generateRoutes(app) {
        const routes = {};
        for (const service of app.services) {
            for (const func of service.funcs) {
                routes[`/${service.name}/${func.name}`] = async (input) => {
                    const api = require(this.pheroExecutionJS);
                    return api[`rpc_executor_${service.name}__${func.name}`](input.body);
                };
            }
        }
        return routes;
    }
    // TODO: Make this more exact?
    clearRequireCache() {
        Object.keys(require.cache).forEach((key) => {
            delete require.cache[key];
        });
    }
}
exports.default = DevServer;
function readBody(request) {
    return new Promise((resolve, reject) => {
        const chunks = [];
        request
            .on("data", (chunk) => {
            chunks.push(chunk);
        })
            .on("end", () => {
            const bodyString = Buffer.concat(chunks).toString();
            resolve(bodyString === "" ? {} : JSON.parse(bodyString));
        })
            .on("error", (err) => {
            reject(err);
        });
    });
}
function computeClientCodeHash(clientCode) {
    return crypto_1.default
        .createHash("sha1")
        .update(JSON.stringify(clientCode))
        .digest("base64");
}
