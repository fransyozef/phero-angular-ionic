"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const core_1 = require("@phero/core");
const dev_1 = require("@phero/dev");
const child_process_1 = __importDefault(require("child_process"));
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const typescript_1 = __importDefault(require("typescript"));
const domain_1 = require("./domain");
const gcloud_functions_1 = __importDefault(require("./gcloud-functions"));
const nodejs_1 = __importDefault(require("./nodejs"));
const vercel_1 = __importDefault(require("./vercel"));
function exportCommand(command) {
    var _a, _b, _c, _d;
    const projectPath = process.cwd();
    const tsConfigFilePath = typescript_1.default.findConfigFile(projectPath, typescript_1.default.sys.fileExists, "tsconfig.json");
    if (!tsConfigFilePath) {
        throw new core_1.MissingTSConfigFile(projectPath);
    }
    const tsConfig = typescript_1.default.getParsedCommandLineOfConfigFile(tsConfigFilePath, undefined, typescript_1.default.sys);
    if (!tsConfig) {
        throw new Error("Can't parse tsconfig.json");
    }
    const hasES2015 = (_a = tsConfig.options.lib) === null || _a === void 0 ? void 0 : _a.some((lib) => /(es2015$)|(es2015\.d\.ts)|(es2015.promise$)|(es2015\.promise\.d\.ts)/.test(lib.toLowerCase()));
    const hasES5 = (_b = tsConfig.options.lib) === null || _b === void 0 ? void 0 : _b.some((lib) => /(es5$)|(es5\.d\.ts)/.test(lib.toLowerCase()));
    const compilerOpts = {
        ...tsConfig.options,
        // declaration: true,
        // NOTE: we need Promise support in our declaration file. In a normal TS project you would add
        // the "es2015". Because we're implementing a file system here, sort of, we need to set the file
        // name more explicitly. (Implementing our own fileExists makes compilation much much faster.)
        lib: [
            ...((_c = tsConfig.options.lib) !== null && _c !== void 0 ? _c : []),
            // support for Promise
            ...(hasES2015 ? [] : ["lib.es2015.d.ts"]),
            // support for Pick, Omit, and other TS utilities
            ...(hasES5 ? [] : ["lib.es5.d.ts"]),
        ],
        // target: ts.ScriptTarget.ES5,
        // module: ts.ModuleKind.CommonJS,
    };
    const compilerHost = typescript_1.default.createCompilerHost(compilerOpts);
    const program = typescript_1.default.createProgram({
        host: compilerHost,
        options: compilerOpts,
        rootNames: [`${projectPath}/src/phero.ts`],
    });
    const tsOutDir = program.getCompilerOptions().outDir;
    if (!tsOutDir) {
        throw new Error('Please provide a "outDir" option in your tsconfig.json file.');
    }
    const exportPath = path_1.default.join(projectPath, ".phero");
    rimRafExport(exportPath);
    rimRafExport(tsOutDir);
    program.emit();
    const pheroSourceFile = program.getSourceFile(`${projectPath}/src/phero.ts`);
    if (!pheroSourceFile) {
        throw new core_1.MissingPheroFileError(projectPath);
    }
    const typeChecker = program.getTypeChecker();
    const app = (0, core_1.parsePheroApp)(pheroSourceFile, typeChecker);
    const dts = (0, core_1.generateAppDeclarationFile)(app, typeChecker);
    const pheroExecution = (0, core_1.generateRPCProxy)(app, typeChecker);
    const lockFile = (_d = findLockFileInDir(projectPath)) !== null && _d !== void 0 ? _d : findLockFileForWorkspace(projectPath);
    if (!lockFile) {
        throw new Error("No lockfile ('package-lock.json', 'yarn.lock' or 'pnpm-lock.yaml') found in the current directory or for any workspace");
    }
    const metaExportFilesBase = {
        "phero-manifest.d.ts": dts,
        "phero-execution.js": pheroExecution.js,
        "phero.js": readFile(path_1.default.join(tsOutDir, "phero.js")),
        "package.json": readFile(path_1.default.join(projectPath, "package.json")),
    };
    let metaExportFiles;
    switch (lockFile.name) {
        case domain_1.MetaExportLockFileName.Npm:
            metaExportFiles = {
                ...metaExportFilesBase,
                [lockFile.name]: readFile(lockFile.path),
            };
            break;
        case domain_1.MetaExportLockFileName.Yarn:
            metaExportFiles = {
                ...metaExportFilesBase,
                [lockFile.name]: readFile(lockFile.path),
            };
            break;
        case domain_1.MetaExportLockFileName.Pnpm:
            metaExportFiles = {
                ...metaExportFilesBase,
                [lockFile.name]: readFile(lockFile.path),
            };
            break;
    }
    switch (command.flavor) {
        case dev_1.ServerExportFlavor.NodeJS: {
            const nodejsExport = (0, nodejs_1.default)(app, metaExportFiles);
            copyTsOutToBundles(tsOutDir, nodejsExport.bundles.map((b) => path_1.default.join(exportPath, b.name)));
            writeToDisk(exportPath, nodejsExport);
            console.log("Done exporting to .phero, to run all your services:");
            console.log("(cd .phero && npm i && node ./index.js)");
            console.log(`To run one specific services, e.g. "${app.services[0].name}":`);
            console.log(`(cd .phero && npm i && node ./${app.services[0].name}/index.js)`);
            break;
        }
        case dev_1.ServerExportFlavor.GCloudFunctions: {
            const gcloudFunctionsExport = (0, gcloud_functions_1.default)(app, metaExportFiles);
            copyTsOutToBundles(tsOutDir, gcloudFunctionsExport.bundles.map((b) => path_1.default.join(exportPath, b.name)));
            writeToDisk(exportPath, gcloudFunctionsExport);
            console.log(`Done exporting ${gcloudFunctionsExport.bundles.length === 1
                ? "1 service"
                : `${gcloudFunctionsExport.bundles.length} services`} to .phero`);
            break;
        }
        case dev_1.ServerExportFlavor.Vercel: {
            const vercelPath = path_1.default.join(projectPath, ".vercel");
            rimRafExport(path_1.default.join(vercelPath, "output"));
            const vercelExport = (0, vercel_1.default)(app, metaExportFiles);
            copyTsOutToBundles(tsOutDir, vercelExport.bundles.map((b) => path_1.default.join(projectPath, b.name)));
            writeToDisk(projectPath, vercelExport);
            for (const bundle of vercelExport.bundles) {
                child_process_1.default.execSync(`npm ci`, {
                    cwd: path_1.default.join(projectPath, bundle.name),
                });
            }
            console.log(`Done exporting ${vercelExport.bundles.length === 1
                ? "1 service"
                : `${vercelExport.bundles.length} services`} to .vercel`);
            console.log(`Now deploy with "npx vercel@latest deploy --prebuilt"`);
            break;
        }
    }
}
exports.default = exportCommand;
function findLockFileInDir(dir) {
    const lockFilePath = path_1.default.join(dir, domain_1.MetaExportLockFileName.Npm);
    if (fs_1.default.existsSync(lockFilePath)) {
        return { name: domain_1.MetaExportLockFileName.Npm, path: lockFilePath };
    }
    const yarnLockFilePath = path_1.default.join(dir, domain_1.MetaExportLockFileName.Yarn);
    if (fs_1.default.existsSync(yarnLockFilePath)) {
        return { name: domain_1.MetaExportLockFileName.Yarn, path: yarnLockFilePath };
    }
    const pnpmLockFilePath = path_1.default.join(dir, domain_1.MetaExportLockFileName.Pnpm);
    if (fs_1.default.existsSync(pnpmLockFilePath)) {
        return { name: domain_1.MetaExportLockFileName.Pnpm, path: pnpmLockFilePath };
    }
    return undefined;
}
function findLockFileForWorkspace(projectPath) {
    const maxDepth = 5;
    let currentPath = projectPath;
    for (let i = 0; i < maxDepth; i++) {
        if (hasWorkspaceSettingsInDir(currentPath)) {
            const foundLockFile = findLockFileInDir(currentPath);
            if (foundLockFile) {
                return foundLockFile;
            }
            else {
                throw new Error("No lockfile found at the same level of where workspace is defined");
            }
        }
        currentPath = path_1.default.join(currentPath, "..");
    }
    return undefined;
}
function hasWorkspaceSettingsInDir(dir) {
    const packageFilePath = path_1.default.join(dir, "package.json");
    if (fs_1.default.existsSync(packageFilePath)) {
        const packageJson = JSON.parse(readFile(packageFilePath));
        return !!packageJson.workspaces;
    }
    const pnpmWorkspaceFilePath = path_1.default.join(dir, "pnpm-workspace.yaml");
    if (fs_1.default.existsSync(pnpmWorkspaceFilePath)) {
        return true;
    }
    return false;
}
function readFile(filePath) {
    return fs_1.default.readFileSync(filePath, {
        encoding: "utf-8",
    });
}
function writeToDisk(exportPath, { bundles, otherFiles }) {
    for (const bundle of bundles) {
        const bundlePath = path_1.default.join(exportPath, bundle.name);
        fs_1.default.mkdirSync(bundlePath, { recursive: true });
        for (const exportFile of bundle.files) {
            const exportFilePath = path_1.default.join(bundlePath, exportFile.name);
            fs_1.default.writeFileSync(exportFilePath, exportFile.content);
        }
    }
    for (const otherFile of otherFiles !== null && otherFiles !== void 0 ? otherFiles : []) {
        const exportFilePath = path_1.default.join(exportPath, otherFile.name);
        fs_1.default.writeFileSync(exportFilePath, otherFile.content);
    }
}
function rimRafExport(exportPath) {
    if (!fs_1.default.existsSync(exportPath)) {
        return;
    }
    rimRafDir(exportPath);
    function rimRafDir(dirPath) {
        const fileNames = fs_1.default.readdirSync(dirPath);
        for (const fileName of fileNames) {
            const subPath = path_1.default.join(dirPath, fileName);
            const lstat = fs_1.default.lstatSync(subPath);
            if (lstat.isDirectory()) {
                rimRafDir(subPath);
            }
            else if (lstat.isFile()) {
                fs_1.default.unlinkSync(subPath);
            }
            else if (lstat.isSymbolicLink()) {
                fs_1.default.unlinkSync(subPath);
            }
        }
        fs_1.default.rmdirSync(dirPath);
    }
}
function copyTsOutToBundles(exportPath, bundlePaths) {
    if (!fs_1.default.existsSync(exportPath)) {
        return;
    }
    recursiveCopy("");
    function copyFile(relativeFilePath) {
        const srcPath = path_1.default.join(exportPath, relativeFilePath);
        for (const bundlePath of bundlePaths) {
            const destPath = path_1.default.join(bundlePath, relativeFilePath);
            fs_1.default.copyFileSync(srcPath, destPath);
        }
    }
    function copyDir(relativeDirPath) {
        for (const bundlePath of bundlePaths) {
            const destPath = path_1.default.join(bundlePath, relativeDirPath);
            fs_1.default.mkdirSync(destPath, { recursive: true });
        }
    }
    function recursiveCopy(relativeDirPath) {
        const fileNames = fs_1.default.readdirSync(path_1.default.join(exportPath, relativeDirPath));
        copyDir(relativeDirPath);
        for (const fileName of fileNames) {
            const relativeFilePath = path_1.default.join(relativeDirPath, fileName);
            const lstat = fs_1.default.lstatSync(path_1.default.join(exportPath, relativeFilePath));
            if (lstat.isDirectory()) {
                recursiveCopy(relativeFilePath);
            }
            else if (lstat.isFile()) {
                copyFile(relativeFilePath);
            }
            else if (lstat.isSymbolicLink()) {
                copyFile(relativeFilePath);
            }
        }
    }
}
