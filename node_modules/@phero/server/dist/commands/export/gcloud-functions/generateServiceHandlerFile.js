"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateServiceHandlerFile = void 0;
const core_1 = require("@phero/core");
const generateExportHelpers_1 = require("../generateExportHelpers");
function generateServiceHandlerFile(service) {
    return [
        core_1.tsx.importDeclaration({
            names: ["writeResponse", "parseServiceAndFunction", "readBody"],
            module: "./lib",
        }),
        core_1.tsx.importDeclaration({
            names: [
                serviceCorsConfig(service),
                ...service.funcs.map((func) => functionExecutor(service, func)),
            ],
            module: "./phero-execution",
        }),
        core_1.tsx.function({
            name: "requestListener",
            export: true,
            async: true,
            returnType: core_1.tsx.type.reference({
                name: "Promise",
                args: [core_1.tsx.type.void],
            }),
            params: [
                core_1.tsx.param({ name: "req", type: core_1.tsx.type.any }),
                core_1.tsx.param({ name: "res", type: core_1.tsx.type.any }),
            ],
            body: [
                core_1.tsx.const({
                    name: "requestedFunction",
                    init: core_1.tsx.expression.call("parseServiceAndFunction", {
                        args: ["req"],
                    }),
                }),
                ...handleService(service),
            ],
        }),
    ];
}
exports.generateServiceHandlerFile = generateServiceHandlerFile;
function serviceCorsConfig(service) {
    return `service_cors_config__${service.name}`;
}
function functionExecutor(service, func) {
    return `rpc_executor_${service.name}__${func.name}`;
}
function handleService(service) {
    return [
        core_1.tsx.const({
            name: "serviceCorsConfig",
            init: core_1.tsx.expression.await(core_1.tsx.expression.call(serviceCorsConfig(service))),
        }),
        core_1.tsx.const({
            name: "originWhitelist",
            init: core_1.tsx.expression.ternary(core_1.tsx.expression.identifier("serviceCorsConfig"), core_1.tsx.expression.propertyAccess("serviceCorsConfig", "originWhitelist"), core_1.tsx.literal.undefined),
        }),
        switchHttpMethods(service),
        core_1.tsx.statement.return(),
    ];
}
function switchHttpMethods(service) {
    return core_1.tsx.statement.switch({
        expression: core_1.tsx.expression.propertyAccess("req", "method"),
        cases: [
            {
                expression: "OPTIONS",
                statements: [
                    (0, generateExportHelpers_1.writeResponseStatement)(core_1.tsx.literal.object(core_1.tsx.property.assignment("status", core_1.tsx.literal.number(200)), core_1.tsx.property.assignment("result", core_1.tsx.literal.string("")))),
                    core_1.tsx.statement.break,
                ],
            },
            {
                expression: "POST",
                statements: [switchService(service), core_1.tsx.statement.break],
            },
        ],
        defaultCase: {
            statements: [(0, generateExportHelpers_1.write404ResponseStatement)(), core_1.tsx.statement.break],
        },
    });
}
function switchService(service) {
    return core_1.tsx.statement.switch({
        expression: core_1.tsx.expression.propertyAccess("requestedFunction", "functionName"),
        cases: service.funcs.map((func) => ({
            expression: func.name,
            statements: [
                core_1.tsx.const({
                    name: `${func.name}Data`,
                    init: core_1.tsx.expression.await(core_1.tsx.expression.call("readBody", {
                        args: ["req"],
                    })),
                }),
                (0, generateExportHelpers_1.writeResponseStatement)(core_1.tsx.expression.await(core_1.tsx.expression.call(functionExecutor(service, func), {
                    args: [`${func.name}Data`],
                }))),
                core_1.tsx.statement.break,
            ],
        })),
        defaultCase: {
            statements: [(0, generateExportHelpers_1.write404ResponseStatement)(), core_1.tsx.statement.break],
        },
    });
}
