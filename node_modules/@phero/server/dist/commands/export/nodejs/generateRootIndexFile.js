"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const core_1 = require("@phero/core");
const typescript_1 = __importDefault(require("typescript"));
const generateExportHelpers_1 = require("../generateExportHelpers");
const factory = typescript_1.default.factory;
function generateRootIndexFile(app) {
    return [
        // import http
        core_1.tsx.importDeclaration({
            names: ["createServer"],
            module: "http",
        }),
        // import lib functions
        core_1.tsx.importDeclaration({
            names: ["writeResponse", "parseServiceAndFunction"],
            module: "./lib",
        }),
        // import services
        ...app.services.map((service) => factory.createImportDeclaration(undefined, factory.createImportClause(false, undefined, factory.createNamedImports([
            factory.createImportSpecifier(false, core_1.tsx.expression.identifier("requestListener"), core_1.tsx.expression.identifier(`service__${service.name}`)),
        ])), factory.createStringLiteral(`./${service.name}/handler`), undefined)),
        generateRequestListener(app),
        (0, generateExportHelpers_1.generateCreateAndStartServer)(),
    ];
}
exports.default = generateRootIndexFile;
function generateRequestListener(app) {
    return core_1.tsx.function({
        name: "requestListener",
        async: true,
        returnType: core_1.tsx.type.reference({
            name: "Promise",
            args: [core_1.tsx.type.void],
        }),
        params: [
            core_1.tsx.param({ name: "req", type: core_1.tsx.type.any }),
            core_1.tsx.param({ name: "res", type: core_1.tsx.type.any }),
        ],
        body: [
            core_1.tsx.const({
                name: "requestedFunction",
                init: core_1.tsx.expression.call("parseServiceAndFunction", {
                    args: [core_1.tsx.expression.propertyAccess("req", "url")],
                }),
            }),
            switchServices(app),
        ],
    });
}
function switchServices(app) {
    return core_1.tsx.statement.switch({
        expression: core_1.tsx.expression.propertyAccess("requestedFunction", "serviceName"),
        cases: app.services.map((service) => ({
            expression: service.name,
            statements: [
                core_1.tsx.statement.expression(core_1.tsx.expression.await(core_1.tsx.expression.call(`service__${service.name}`, {
                    args: ["req", "res"],
                }))),
                core_1.tsx.statement.return(),
            ],
        })),
        defaultCase: {
            statements: [
                core_1.tsx.const({ name: "originWhitelist", init: core_1.tsx.literal.undefined }),
                (0, generateExportHelpers_1.write404ResponseStatement)(),
                core_1.tsx.statement.break,
            ],
        },
    });
}
