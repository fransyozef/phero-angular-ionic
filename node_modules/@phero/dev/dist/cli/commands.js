"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.parsePheroCommand = exports.parseClientCommand = exports.parseServerCommand = exports.PheroCommandName = exports.ClientCommandName = exports.ServerExportFlavor = exports.ServerCommandName = exports.DEFAULT_CLIENT_PORT = exports.DEFAULT_SERVER_URL = exports.DEFAULT_SERVER_PORT = void 0;
const arg_1 = __importDefault(require("arg"));
exports.DEFAULT_SERVER_PORT = 3030;
exports.DEFAULT_SERVER_URL = `http://localhost:${exports.DEFAULT_SERVER_PORT}`;
exports.DEFAULT_CLIENT_PORT = 4040;
// Server
var ServerCommandName;
(function (ServerCommandName) {
    ServerCommandName["Version"] = "version";
    ServerCommandName["Help"] = "help";
    ServerCommandName["Serve"] = "serve";
    ServerCommandName["Export"] = "export";
    ServerCommandName["Build"] = "build";
})(ServerCommandName = exports.ServerCommandName || (exports.ServerCommandName = {}));
var ServerExportFlavor;
(function (ServerExportFlavor) {
    ServerExportFlavor["NodeJS"] = "nodejs";
    ServerExportFlavor["GCloudFunctions"] = "gcloud-functions";
    ServerExportFlavor["Vercel"] = "vercel";
})(ServerExportFlavor = exports.ServerExportFlavor || (exports.ServerExportFlavor = {}));
// Client
var ClientCommandName;
(function (ClientCommandName) {
    ClientCommandName["Version"] = "version";
    ClientCommandName["Help"] = "help";
    ClientCommandName["Watch"] = "watch";
    ClientCommandName["Build"] = "build";
})(ClientCommandName = exports.ClientCommandName || (exports.ClientCommandName = {}));
// Phero
var PheroCommandName;
(function (PheroCommandName) {
    PheroCommandName["Version"] = "version";
    PheroCommandName["Help"] = "help";
    PheroCommandName["Server"] = "server";
    PheroCommandName["Client"] = "client";
    PheroCommandName["DevEnv"] = "dev-env";
    PheroCommandName["Init"] = "init";
})(PheroCommandName = exports.PheroCommandName || (exports.PheroCommandName = {}));
function parseServerCommand(argv) {
    var _a;
    const args = (0, arg_1.default)({
        "--version": Boolean,
        "--help": Boolean,
        "--verbose": Boolean,
        "--port": Number,
        "--flavor": String,
        "-v": "--version",
        "-h": "--help",
        "-p": "--port",
    }, { argv });
    const name = args["_"][0];
    const verbose = !!args["--verbose"];
    if (args["--help"]) {
        return { name: ServerCommandName.Help, command: name };
    }
    if (args["--version"]) {
        return { name: ServerCommandName.Version };
    }
    switch (name) {
        case ServerCommandName.Serve:
            const port = (_a = args["--port"]) !== null && _a !== void 0 ? _a : exports.DEFAULT_SERVER_PORT;
            return { name, verbose, port };
        case ServerCommandName.Export:
            const flavor = parseServerExportFlavor(args["--flavor"]);
            return { name, flavor, verbose };
        case ServerCommandName.Build:
            return { name, verbose };
        default:
            throw new Error(`Unknown server command: ${name}`);
    }
}
exports.parseServerCommand = parseServerCommand;
function parseClientCommand(argv) {
    var _a;
    const args = (0, arg_1.default)({
        "--version": Boolean,
        "--help": Boolean,
        "--verbose": Boolean,
        "--port": Number,
        "-v": "--version",
        "-h": "--help",
        "-p": "--port",
    }, { argv });
    const name = args["_"][0];
    const location = args["_"][1]; // TODO: Is there a better way?
    const verbose = !!args["--verbose"];
    if (args["--help"]) {
        return { name: ClientCommandName.Help, command: name };
    }
    if (args["--version"]) {
        return { name: ClientCommandName.Version };
    }
    switch (name) {
        case ClientCommandName.Watch:
            const port = (_a = args["--port"]) !== null && _a !== void 0 ? _a : exports.DEFAULT_CLIENT_PORT;
            if (!location) {
                return { name, verbose, port, server: { url: exports.DEFAULT_SERVER_URL } };
            }
            else if (location.startsWith("http")) {
                return { name, verbose, port, server: { url: location } };
            }
            else {
                throw new Error("Watching based on file path is not supported ");
            }
        case ClientCommandName.Build:
            if (!location) {
                return { name, verbose, server: { url: exports.DEFAULT_SERVER_URL } };
            }
            else if (location.startsWith("http")) {
                return { name, verbose, server: { url: location } };
            }
            else {
                return { name, verbose, server: { path: location } };
            }
        default:
            throw new Error(`unknown client command: ${name}`);
    }
}
exports.parseClientCommand = parseClientCommand;
function parsePheroCommand(argv) {
    const args = (0, arg_1.default)({
        "--version": Boolean,
        "--help": Boolean,
        "--verbose": Boolean,
        "-v": "--version",
        "-h": "--help",
    }, { argv, permissive: true });
    const name = args["_"][0];
    const verbose = !!args["--verbose"];
    if (name === PheroCommandName.Client || name === PheroCommandName.Server) {
        return { name, argv: argv.slice(1) };
    }
    if (args["--help"]) {
        return { name: PheroCommandName.Help, command: name };
    }
    if (args["--version"]) {
        return { name: PheroCommandName.Version };
    }
    if (name === PheroCommandName.Init) {
        if (argv[1] === "client") {
            return { name, env: "client" };
        }
        else if (argv[1] === "server") {
            return { name, env: "server" };
        }
        else {
            return { name };
        }
    }
    if (name === undefined) {
        return {
            name: PheroCommandName.DevEnv,
            verbose,
        };
    }
    else {
        throw new Error(`unknown phero command: ${name}`);
    }
}
exports.parsePheroCommand = parsePheroCommand;
function parseServerExportFlavor(flavor) {
    switch (flavor) {
        case ServerExportFlavor.NodeJS:
            return ServerExportFlavor.NodeJS;
        case ServerExportFlavor.GCloudFunctions:
            return ServerExportFlavor.GCloudFunctions;
        case ServerExportFlavor.Vercel:
            return ServerExportFlavor.Vercel;
        default:
            throw new Error(`Required flavor parameter, must be one of: ${[
                ServerExportFlavor.NodeJS,
                ServerExportFlavor.GCloudFunctions,
                ServerExportFlavor.Vercel,
            ].join(", ")}`);
    }
}
