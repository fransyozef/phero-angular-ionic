"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.isModel = exports.parseAppDeclarationFileContent = void 0;
const typescript_1 = __importDefault(require("typescript"));
const errors_1 = require("./errors");
const tsUtils_1 = require("./tsUtils");
const VirtualCompilerHost_1 = require("./VirtualCompilerHost");
function parseAppDeclarationFileContent(dts) {
    const vHost = new VirtualCompilerHost_1.VirtualCompilerHost();
    vHost.addFile("api.d.ts", dts);
    const program = vHost.createProgram("api.d.ts");
    program.emit();
    const sourceFile = program.getSourceFile("api.d.ts");
    if (!sourceFile) {
        throw new Error("Can't compile declaration file");
    }
    const result = parseAppDeclarationSourceFile(sourceFile);
    return { result, typeChecker: program.getTypeChecker() };
}
exports.parseAppDeclarationFileContent = parseAppDeclarationFileContent;
function parseAppDeclarationSourceFile(sourceFile) {
    const modules = sourceFile.statements
        .filter(isUserModule)
        .map(parseModule);
    const domainModule = modules.find((m) => m.name === "domain");
    const serviceModules = modules.filter((m) => m.name !== "domain");
    const parsedDomainDeclr = domainModule
        ? parseDomainDeclarations(domainModule)
        : {};
    const parsedServicesDeclarations = serviceModules.map(parseServiceDeclaration);
    return {
        domain: parsedDomainDeclr,
        services: parsedServicesDeclarations,
    };
}
function parseDomainDeclarations({ statements, }) {
    const versionModules = statements.map(parseModule);
    return versionModules.reduce((result, versionModule) => ({
        ...result,
        [versionModule.name]: parseServiceDeclarationVersion(versionModule.statements),
    }), {});
}
function parseServiceDeclaration({ name, statements, }) {
    const versionModules = statements.map(parseModule);
    return {
        name,
        versions: versionModules.reduce((result, versionModule) => ({
            ...result,
            [versionModule.name]: parseServiceDeclarationVersion(versionModule.statements),
        }), {}),
    };
}
function parseServiceDeclarationVersion(statements) {
    return statements.reduce(({ models, functions, context, errors }, st) => {
        if (isModel(st)) {
            return { models: [...models, st], functions, context, errors };
        }
        if (typescript_1.default.isFunctionDeclaration(st)) {
            return {
                models,
                functions: [...functions, st],
                context: context !== null && context !== void 0 ? context : parseContextType(st),
                errors,
            };
        }
        if (typescript_1.default.isClassDeclaration(st)) {
            return {
                models,
                functions,
                context,
                errors: [...errors, st],
            };
        }
        throw new errors_1.ParseError("S103: We only support enums, functions, Error classes, interfaces and type aliases", st);
    }, {
        models: [],
        functions: [],
        context: undefined,
        errors: [],
    });
}
function parseContextType(func) {
    var _a;
    const firstParam = func.parameters[0];
    if ((firstParam === null || firstParam === void 0 ? void 0 : firstParam.type) &&
        typescript_1.default.isTypeReferenceNode(firstParam.type) &&
        (0, tsUtils_1.getNameAsString)(firstParam.type.typeName) === "PheroContext") {
        return (_a = firstParam.type.typeArguments) === null || _a === void 0 ? void 0 : _a[0];
    }
    return undefined;
}
function isModel(node) {
    return (typescript_1.default.isInterfaceDeclaration(node) ||
        typescript_1.default.isTypeAliasDeclaration(node) ||
        typescript_1.default.isEnumDeclaration(node));
}
exports.isModel = isModel;
function parseModule(statement) {
    if (typescript_1.default.isModuleDeclaration(statement) &&
        (statement === null || statement === void 0 ? void 0 : statement.body) &&
        typescript_1.default.isModuleBlock(statement.body)) {
        return {
            name: statement.name.getText(),
            statements: statement.body.statements.map((st) => st),
        };
    }
    throw new errors_1.ParseError("S104: Unexpected statement", statement);
}
function isUserModule(statement) {
    return (!typescript_1.default.isModuleDeclaration(statement) ||
        // skip the phero namespace
        statement.name.text !== "phero");
}
