"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const typescript_1 = __importDefault(require("typescript"));
const tsTestUtils_1 = require("../tsTestUtils");
const generateParser_1 = __importDefault(require("./parsers/generateParser"));
describe("Parsers", () => {
    describe("for a type alias", () => {
        describe("object literal", () => {
            test("with no members", () => {
                const { statement: model, typeChecker } = (0, tsTestUtils_1.compileStatement)(`
          type MyModel = {}
        `, typescript_1.default.SyntaxKind.TypeAliasDeclaration);
                const parserDeclaration = (0, generateParser_1.default)(model, typeChecker);
                expect((0, tsTestUtils_1.printCode)(parserDeclaration)).toMatchSnapshot();
            });
            test("number member", () => {
                const { statement: model, typeChecker } = (0, tsTestUtils_1.compileStatement)(`
          type MyModel = {
            a: number
          }
        `, typescript_1.default.SyntaxKind.TypeAliasDeclaration);
                const parserDeclaration = (0, generateParser_1.default)(model, typeChecker);
                expect((0, tsTestUtils_1.printCode)(parserDeclaration)).toMatchSnapshot();
            });
            test("number model", () => {
                const { statement: model, typeChecker } = (0, tsTestUtils_1.compileStatement)(`
          type MyModel = number
        `, typescript_1.default.SyntaxKind.TypeAliasDeclaration);
                const parserDeclaration = (0, generateParser_1.default)(model, typeChecker);
                expect((0, tsTestUtils_1.printCode)(parserDeclaration)).toMatchSnapshot();
            });
            test("string member", () => {
                const { statement: model, typeChecker } = (0, tsTestUtils_1.compileStatement)(`
          type MyModel = {
            a: string
          }
        `, typescript_1.default.SyntaxKind.TypeAliasDeclaration);
                const parserDeclaration = (0, generateParser_1.default)(model, typeChecker);
                expect((0, tsTestUtils_1.printCode)(parserDeclaration)).toMatchSnapshot();
            });
            test("boolean member", () => {
                const { statement: model, typeChecker } = (0, tsTestUtils_1.compileStatement)(`
          type MyModel = {
            a: boolean
          }
        `, typescript_1.default.SyntaxKind.TypeAliasDeclaration);
                const parserDeclaration = (0, generateParser_1.default)(model, typeChecker);
                expect((0, tsTestUtils_1.printCode)(parserDeclaration)).toMatchSnapshot();
            });
            test("null member", () => {
                const { statement: model, typeChecker } = (0, tsTestUtils_1.compileStatement)(`
          type MyModel = {
            a: null
          }
        `, typescript_1.default.SyntaxKind.TypeAliasDeclaration);
                const parserDeclaration = (0, generateParser_1.default)(model, typeChecker);
                expect((0, tsTestUtils_1.printCode)(parserDeclaration)).toMatchSnapshot();
            });
            test("optional member", () => {
                const { statement: model, typeChecker } = (0, tsTestUtils_1.compileStatement)(`
          type MyModel = {
            a?: string
          }
        `, typescript_1.default.SyntaxKind.TypeAliasDeclaration);
                const parserDeclaration = (0, generateParser_1.default)(model, typeChecker);
                expect((0, tsTestUtils_1.printCode)(parserDeclaration)).toMatchSnapshot();
            });
            test("string literal member", () => {
                const { statement: model, typeChecker } = (0, tsTestUtils_1.compileStatement)(`
          type MyModel = {
            a: "xxx"
          }
        `, typescript_1.default.SyntaxKind.TypeAliasDeclaration);
                const parserDeclaration = (0, generateParser_1.default)(model, typeChecker);
                expect((0, tsTestUtils_1.printCode)(parserDeclaration)).toMatchSnapshot();
            });
            test("number literal member", () => {
                const { statement: model, typeChecker } = (0, tsTestUtils_1.compileStatement)(`
          type MyModel = {
            a: 123
          }
        `, typescript_1.default.SyntaxKind.TypeAliasDeclaration);
                const parserDeclaration = (0, generateParser_1.default)(model, typeChecker);
                expect((0, tsTestUtils_1.printCode)(parserDeclaration)).toMatchSnapshot();
            });
            test("true literal member", () => {
                const { statement: model, typeChecker } = (0, tsTestUtils_1.compileStatement)(`
          type MyModel = {
            a: true
          }
        `, typescript_1.default.SyntaxKind.TypeAliasDeclaration);
                const parserDeclaration = (0, generateParser_1.default)(model, typeChecker);
                expect((0, tsTestUtils_1.printCode)(parserDeclaration)).toMatchSnapshot();
            });
            test("string array member", () => {
                const { statement: model, typeChecker } = (0, tsTestUtils_1.compileStatement)(`
          type MyModel = {
            a: string[]
          }
        `, typescript_1.default.SyntaxKind.TypeAliasDeclaration);
                const parserDeclaration = (0, generateParser_1.default)(model, typeChecker);
                expect((0, tsTestUtils_1.printCode)(parserDeclaration)).toMatchSnapshot();
            });
            test("optional string array member", () => {
                const { statement: model, typeChecker } = (0, tsTestUtils_1.compileStatement)(`
          type MyModel = {
            a?: string[]
          }
        `, typescript_1.default.SyntaxKind.TypeAliasDeclaration);
                const parserDeclaration = (0, generateParser_1.default)(model, typeChecker);
                expect((0, tsTestUtils_1.printCode)(parserDeclaration)).toMatchSnapshot();
            });
            test("number array member", () => {
                const { statement: model, typeChecker } = (0, tsTestUtils_1.compileStatement)(`
          type MyModel = {
            a: number[]
          }
        `, typescript_1.default.SyntaxKind.TypeAliasDeclaration);
                const parserDeclaration = (0, generateParser_1.default)(model, typeChecker);
                expect((0, tsTestUtils_1.printCode)(parserDeclaration)).toMatchSnapshot();
            });
            test("boolean array member", () => {
                const { statement: model, typeChecker } = (0, tsTestUtils_1.compileStatement)(`
          type MyModel = {
            a: boolean[]
          }
        `, typescript_1.default.SyntaxKind.TypeAliasDeclaration);
                const parserDeclaration = (0, generateParser_1.default)(model, typeChecker);
                expect((0, tsTestUtils_1.printCode)(parserDeclaration)).toMatchSnapshot();
            });
            test("object literal member", () => {
                const { statement: model, typeChecker } = (0, tsTestUtils_1.compileStatement)(`
          type MyModel = {
            a: {b: number}[]
          }
        `, typescript_1.default.SyntaxKind.TypeAliasDeclaration);
                const parserDeclaration = (0, generateParser_1.default)(model, typeChecker);
                expect((0, tsTestUtils_1.printCode)(parserDeclaration)).toMatchSnapshot();
            });
            test("optional object literal member", () => {
                const { statement: model, typeChecker } = (0, tsTestUtils_1.compileStatement)(`
          type MyModel = {
            a?: {b: number}[]
          }
        `, typescript_1.default.SyntaxKind.TypeAliasDeclaration);
                const parserDeclaration = (0, generateParser_1.default)(model, typeChecker);
                expect((0, tsTestUtils_1.printCode)(parserDeclaration)).toMatchSnapshot();
            });
            test("optional object literal with optional member", () => {
                const { statement: model, typeChecker } = (0, tsTestUtils_1.compileStatement)(`
          type MyModel = {
            a?: {
              b?: number
            }
          }
        `, typescript_1.default.SyntaxKind.TypeAliasDeclaration);
                const parserDeclaration = (0, generateParser_1.default)(model, typeChecker);
                expect((0, tsTestUtils_1.printCode)(parserDeclaration)).toMatchSnapshot();
            });
            test("deep nested object", () => {
                const { statement: model, typeChecker } = (0, tsTestUtils_1.compileStatement)(`
          type MyModel = {
            a: {
              b?: {c: { d?: number }}[]
            }
          }
        `, typescript_1.default.SyntaxKind.TypeAliasDeclaration);
                const parserDeclaration = (0, generateParser_1.default)(model, typeChecker);
                expect((0, tsTestUtils_1.printCode)(parserDeclaration)).toMatchSnapshot();
            });
        });
        describe("tuple", () => {
            test("simple", () => {
                const { statement: model, typeChecker } = (0, tsTestUtils_1.compileStatement)(`
          type MyModel = [string, number]
        `, typescript_1.default.SyntaxKind.TypeAliasDeclaration);
                const parserDeclaration = (0, generateParser_1.default)(model, typeChecker);
                expect((0, tsTestUtils_1.printCode)(parserDeclaration)).toMatchSnapshot();
            });
            test("tuple with typealias", () => {
                const { statement: model, typeChecker } = (0, tsTestUtils_1.compileStatement)(`
          type MyModel = [string, {a: number}]
        `, typescript_1.default.SyntaxKind.TypeAliasDeclaration);
                const parserDeclaration = (0, generateParser_1.default)(model, typeChecker);
                expect((0, tsTestUtils_1.printCode)(parserDeclaration)).toMatchSnapshot();
            });
            test("tuple within tuple", () => {
                const { statement: model, typeChecker } = (0, tsTestUtils_1.compileStatement)(`
          type MyModel = [string, [{a: number}, boolean]]
        `, typescript_1.default.SyntaxKind.TypeAliasDeclaration);
                const parserDeclaration = (0, generateParser_1.default)(model, typeChecker);
                expect((0, tsTestUtils_1.printCode)(parserDeclaration)).toMatchSnapshot();
            });
        });
        describe("union", () => {
            test("simple", () => {
                const { statement: model, typeChecker } = (0, tsTestUtils_1.compileStatement)(`
          type MyModel = string | number
        `, typescript_1.default.SyntaxKind.TypeAliasDeclaration);
                const parserDeclaration = (0, generateParser_1.default)(model, typeChecker);
                expect((0, tsTestUtils_1.printCode)(parserDeclaration)).toMatchSnapshot();
            });
            test("with type literal", () => {
                const { statement: model, typeChecker } = (0, tsTestUtils_1.compileStatement)(`
          type MyModel = string | {a: number}
        `, typescript_1.default.SyntaxKind.TypeAliasDeclaration);
                const parserDeclaration = (0, generateParser_1.default)(model, typeChecker);
                expect((0, tsTestUtils_1.printCode)(parserDeclaration)).toMatchSnapshot();
            });
            test("with tuple", () => {
                const { statement: model, typeChecker } = (0, tsTestUtils_1.compileStatement)(`
          type MyModel = string | [{a: number}, string]
        `, typescript_1.default.SyntaxKind.TypeAliasDeclaration);
                const parserDeclaration = (0, generateParser_1.default)(model, typeChecker);
                expect((0, tsTestUtils_1.printCode)(parserDeclaration)).toMatchSnapshot();
            });
            test("with tuple", () => {
                const { statement: model, typeChecker } = (0, tsTestUtils_1.compileStatement)(`
          type MyModel = {a: string, b: number} | {a: number, b: string}
        `, typescript_1.default.SyntaxKind.TypeAliasDeclaration);
                const parserDeclaration = (0, generateParser_1.default)(model, typeChecker);
                expect((0, tsTestUtils_1.printCode)(parserDeclaration)).toMatchSnapshot();
            });
        });
        describe("intersection", () => {
            test("simple", () => {
                const { statement: model, typeChecker } = (0, tsTestUtils_1.compileStatement)(`
          type MyModel = {a: string} & {b: string}
        `, typescript_1.default.SyntaxKind.TypeAliasDeclaration);
                const parserDeclaration = (0, generateParser_1.default)(model, typeChecker);
                expect((0, tsTestUtils_1.printCode)(parserDeclaration)).toMatchSnapshot();
            });
            test("object literal with union", () => {
                const { statement: model, typeChecker } = (0, tsTestUtils_1.compileStatement)(`
          type MyModel = {a: string} & ({b: number} | {c: boolean})
        `, typescript_1.default.SyntaxKind.TypeAliasDeclaration);
                const parserDeclaration = (0, generateParser_1.default)(model, typeChecker);
                expect((0, tsTestUtils_1.printCode)(parserDeclaration)).toMatchSnapshot();
            });
            test("object literal with complex union", () => {
                const { statement: model, typeChecker } = (0, tsTestUtils_1.compileStatement)(`
          type MyModel = {a: string} & ({b: number, c: {d:123}} | {c: boolean, b: string})
        `, typescript_1.default.SyntaxKind.TypeAliasDeclaration);
                const parserDeclaration = (0, generateParser_1.default)(model, typeChecker);
                expect((0, tsTestUtils_1.printCode)(parserDeclaration)).toMatchSnapshot();
            });
            test("intersection with two types", () => {
                const { statements: [model], typeChecker, } = (0, tsTestUtils_1.compileStatements)(`
          type MyModel = A | B

          type A = {
            a: number
          }
          type B = {
            b: number
          }
        `);
                const parserDeclaration = (0, generateParser_1.default)(model, typeChecker);
                expect((0, tsTestUtils_1.printCode)(parserDeclaration)).toMatchSnapshot();
            });
            test("intersection with two interfaces", () => {
                const { statements: [model], typeChecker, } = (0, tsTestUtils_1.compileStatements)(`
          type MyModel = A & B

          interface A {
            a: number
          }
          interface B {
            b: number
          }
        `);
                const parserDeclaration = (0, generateParser_1.default)(model, typeChecker);
                expect((0, tsTestUtils_1.printCode)(parserDeclaration)).toMatchSnapshot();
            });
        });
        describe("typescript utility types", () => {
            test("Pick", () => {
                const { statement: model, typeChecker } = (0, tsTestUtils_1.compileStatement)(`
        type MyModel = {
          a: Pick<{a: string, b: boolean, c:number}, "b">
        }
      `, typescript_1.default.SyntaxKind.TypeAliasDeclaration);
                const parserDeclaration = (0, generateParser_1.default)(model, typeChecker);
                expect((0, tsTestUtils_1.printCode)(parserDeclaration)).toMatchSnapshot();
            });
            test("Omit", () => {
                const { statements: [model], typeChecker, } = (0, tsTestUtils_1.compileStatements)(`
          type MyModel = {
            a: Omit<Aad, "c">
          }  
          interface Aad {
            kees: {
              a: number
            }
            c: number
          }
          interface Aad {
            kees: {
              b: number
            }
          }
      `);
                const parserDeclaration = (0, generateParser_1.default)(model, typeChecker);
                expect((0, tsTestUtils_1.printCode)(parserDeclaration)).toMatchSnapshot();
            });
        });
        describe("Generics", () => {
            test("native generic", () => {
                const { statements: [model], typeChecker, } = (0, tsTestUtils_1.compileStatements)(`
        type MyModel<T> = {
          a: T
        }
      `);
                const parserDeclaration = (0, generateParser_1.default)(model, typeChecker);
                expect((0, tsTestUtils_1.printCode)(parserDeclaration)).toMatchSnapshot();
            });
        });
        describe("Reference", () => {
            test("to another interface", () => {
                const { statements: [model], typeChecker, } = (0, tsTestUtils_1.compileStatements)(`
        type MyModel = {
          a: Aad
        }
        interface Aad {
          a: number
        }
      `);
                const parserDeclaration = (0, generateParser_1.default)(model, typeChecker);
                expect((0, tsTestUtils_1.printCode)(parserDeclaration)).toMatchSnapshot();
            });
            test("to another interface with a type parameter", () => {
                const { statements: [model], typeChecker, } = (0, tsTestUtils_1.compileStatements)(`
        type MyModel = {
          a: Aad<number>
        }
        interface Aad<T> {
          a: T
        }
      `);
                const parserDeclaration = (0, generateParser_1.default)(model, typeChecker);
                expect((0, tsTestUtils_1.printCode)(parserDeclaration)).toMatchSnapshot();
            });
            test("to another interface with a type parameter with a default", () => {
                const { statements: [model], typeChecker, } = (0, tsTestUtils_1.compileStatements)(`
        type MyModel = {
          a: Aad<number>
        }
        interface Aad<T = number> {
          a: T
        }
      `);
                const parserDeclaration = (0, generateParser_1.default)(model, typeChecker);
                expect((0, tsTestUtils_1.printCode)(parserDeclaration)).toMatchSnapshot();
            });
            test("to another interface with the default type parameter", () => {
                const { statements: [model], typeChecker, } = (0, tsTestUtils_1.compileStatements)(`
        type MyModel = {
          a: Aad
        }
        interface Aad<T = number> {
          a: T
        }
      `);
                const parserDeclaration = (0, generateParser_1.default)(model, typeChecker);
                expect((0, tsTestUtils_1.printCode)(parserDeclaration)).toMatchSnapshot();
            });
            test("to another interface with own default type parameter", () => {
                const { statements: [model], typeChecker, } = (0, tsTestUtils_1.compileStatements)(`
        type MyModel<T = number> = {
          a: Aad<T>
        }
        interface Aad<T> {
          a: T
        }
      `);
                const parserDeclaration = (0, generateParser_1.default)(model, typeChecker);
                expect((0, tsTestUtils_1.printCode)(parserDeclaration)).toMatchSnapshot();
            });
            test("to another interface with mixed type parameters", () => {
                const { statements: [model], typeChecker, } = (0, tsTestUtils_1.compileStatements)(`
        type MyModel<T, X = number> = {
          a: Aad<T>
          b: Aad<string>
          c: Aad<number>
          d: Aad<X>
          e: Aad
        }
        interface Aad<T = boolean> {
          a: T
        }
      `);
                const parserDeclaration = (0, generateParser_1.default)(model, typeChecker);
                expect((0, tsTestUtils_1.printCode)(parserDeclaration)).toMatchSnapshot();
            });
        });
        describe("recursive types", () => {
            test("simple", () => {
                const { statements: [model], typeChecker, } = (0, tsTestUtils_1.compileStatements)(`
        type MyModel = {
          prop1: number
          prop2?: MyModel
        }
      `);
                const parserDeclaration = (0, generateParser_1.default)(model, typeChecker);
                expect((0, tsTestUtils_1.printCode)(parserDeclaration)).toMatchSnapshot();
            });
            test("Tree", () => {
                const { statements: [model1, model2, model3, model4], typeChecker, } = (0, tsTestUtils_1.compileStatements)(`
          type NumberTree = Tree<number>

          type Tree<T> = Leaf<T> | Branch<T>

          type Leaf<A> = {
            type: "leaf"
            value: A;
          }

          type Branch<A> = {
            type: "branch"
            left: Tree<A>;
            right: Tree<A>;
          }
      `);
                const parserDeclaration1 = (0, generateParser_1.default)(model1, typeChecker);
                const parserDeclaration2 = (0, generateParser_1.default)(model2, typeChecker);
                const parserDeclaration3 = (0, generateParser_1.default)(model3, typeChecker);
                const parserDeclaration4 = (0, generateParser_1.default)(model4, typeChecker);
                expect((0, tsTestUtils_1.printCode)(parserDeclaration1)).toMatchSnapshot();
                expect((0, tsTestUtils_1.printCode)(parserDeclaration2)).toMatchSnapshot();
                expect((0, tsTestUtils_1.printCode)(parserDeclaration3)).toMatchSnapshot();
                expect((0, tsTestUtils_1.printCode)(parserDeclaration4)).toMatchSnapshot();
            });
        });
        describe("index types", () => {
            test("string keys", () => {
                const { statements: [model], typeChecker, } = (0, tsTestUtils_1.compileStatements)(`
        type MyModel = {
          [key: string]: {
            a: string
          }
        }
      `);
                const parserDeclaration = (0, generateParser_1.default)(model, typeChecker);
                expect((0, tsTestUtils_1.printCode)(parserDeclaration)).toMatchSnapshot();
            });
            test("number keys", () => {
                const { statements: [model], typeChecker, } = (0, tsTestUtils_1.compileStatements)(`
        type MyModel = {
          [key: number]: {
            a: string
          }
        }
      `);
                const parserDeclaration = (0, generateParser_1.default)(model, typeChecker);
                expect((0, tsTestUtils_1.printCode)(parserDeclaration)).toMatchSnapshot();
            });
            test("union string keys", () => {
                const { statements: [model], typeChecker, } = (0, tsTestUtils_1.compileStatements)(`
        type MyModel = {
          [name: "aap" | "noot"]: {
            a: string
          }
        }
      `);
                const parserDeclaration = (0, generateParser_1.default)(model, typeChecker);
                expect((0, tsTestUtils_1.printCode)(parserDeclaration)).toMatchSnapshot();
            });
            test("union number keys", () => {
                const { statements: [model], typeChecker, } = (0, tsTestUtils_1.compileStatements)(`
        type MyModel = {
          [name: 10 | 20]: {
            a: string
          }
        }
      `);
                const parserDeclaration = (0, generateParser_1.default)(model, typeChecker);
                expect((0, tsTestUtils_1.printCode)(parserDeclaration)).toMatchSnapshot();
            });
            test("keyof keys", () => {
                const { statements: [model], typeChecker, } = (0, tsTestUtils_1.compileStatements)(`
        type MyModel = {
          [name in keyof Kees]: {
            a: string
          }
        }
        interface Kees {
          aap: string
          noot: number
        }
      `);
                const parserDeclaration = (0, generateParser_1.default)(model, typeChecker);
                expect((0, tsTestUtils_1.printCode)(parserDeclaration)).toMatchSnapshot();
            });
        });
        describe("IndexedAccessTypeNode", () => {
            test("native member", () => {
                const { statements: [model], typeChecker, } = (0, tsTestUtils_1.compileStatements)(`
            type Tree = {
              aad: Aad["banaan"]
            }

            type Aad = {
              banaan: number
            }
          `);
                const parserDeclaration = (0, generateParser_1.default)(model, typeChecker);
                expect((0, tsTestUtils_1.printCode)(parserDeclaration)).toMatchSnapshot();
            });
            test("type element member", () => {
                const { statements: [model], typeChecker, } = (0, tsTestUtils_1.compileStatements)(`
            type Tree = {
              aad: Aad["banaan"]
            }

            type Aad = {
              banaan: {
                kaas: number
              }
            }
          `);
                const parserDeclaration = (0, generateParser_1.default)(model, typeChecker);
                expect((0, tsTestUtils_1.printCode)(parserDeclaration)).toMatchSnapshot();
            });
            test("reference member", () => {
                const { statements: [model], typeChecker, } = (0, tsTestUtils_1.compileStatements)(`
            type Tree = {
              aad: Aad["banaan"]
            }

            type Aad = {
              banaan: Banaan
            }

            interface Banaan {
              kaas: number
            }
          `);
                const parserDeclaration = (0, generateParser_1.default)(model, typeChecker);
                expect((0, tsTestUtils_1.printCode)(parserDeclaration)).toMatchSnapshot();
            });
        });
    });
});
