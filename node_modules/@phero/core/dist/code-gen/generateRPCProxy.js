"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateInlineParser = void 0;
const typescript_1 = __importDefault(require("typescript"));
const __1 = require("..");
const parseReturnType_1 = __importDefault(require("../parsePheroApp/parseReturnType"));
const tsTestUtils_1 = require("../tsTestUtils");
const VirtualCompilerHost_1 = require("../VirtualCompilerHost");
const generateParser_1 = __importStar(require("./parsers/generateParser"));
const generateParserFromModel_1 = __importDefault(require("./parsers/generateParserFromModel"));
const generateParserModel_1 = __importDefault(require("./parsers/generateParserModel"));
const generateMiddlewareParsers_1 = __importDefault(require("../generateMiddlewareParsers"));
const tsx = __importStar(require("../tsx"));
const factory = typescript_1.default.factory;
function generateRPCProxy(app, typeChecker) {
    var _a;
    const tsNodes = [];
    tsNodes.push(factory.createImportDeclaration(undefined, factory.createImportClause(false, undefined, factory.createNamedImports(app.services.map((service) => factory.createImportSpecifier(false, undefined, factory.createIdentifier(service.name))))), factory.createStringLiteral("./phero"), undefined));
    tsNodes.push(...types);
    tsNodes.push(tsx.verbatim(`
    type Defer<T = void> = {
      resolve: (result: T) => void
      reject: (err: Error) => void
      promise: Promise<T>
    }

    function defer<T>(): Defer<T> {
      const deferred: Defer<T> = {} as Defer<T>
      const promise = new Promise<T>((resolve, reject) => {
        deferred.resolve = (result: T) => resolve(result)
        deferred.reject = (err: Error) => reject(err)
      })
      deferred.promise = promise
      return deferred
    }

    class ContextParseError extends Error {
      constructor(public readonly errors: ValidationError[], public readonly input: any) {
        super("ContextParseError")
        // https://github.com/microsoft/TypeScript/issues/22585
        Object.setPrototypeOf(this, ContextParseError.prototype)
      }
    }
  `));
    for (const domainModel of app.models) {
        tsNodes.push(domainModel);
        tsNodes.push((0, generateParser_1.default)(domainModel, typeChecker));
    }
    for (const service of app.services) {
        tsNodes.push(generateCorsConfigFunction(service));
        if ((_a = service.config.middleware) === null || _a === void 0 ? void 0 : _a.length) {
            tsNodes.push((0, generateMiddlewareParsers_1.default)(service.name, service.config, typeChecker));
        }
        for (const serviceModel of service.models) {
            tsNodes.push(serviceModel, (0, generateParser_1.default)(serviceModel, typeChecker));
        }
        for (const serviceFunction of service.funcs) {
            tsNodes.push(generateRPCExecutor(service, serviceFunction, app.errors, typeChecker), generateInnerFunction(service, serviceFunction, typeChecker));
        }
    }
    const printer = typescript_1.default.createPrinter({
        newLine: typescript_1.default.NewLineKind.LineFeed,
        removeComments: true,
    });
    const file = typescript_1.default.createSourceFile("phero-execution.ts", "", typescript_1.default.ScriptTarget.ES2015, // TODO should respect the target of the user
    false, typescript_1.default.ScriptKind.TS);
    const tsPheroExecution = printer.printList(typescript_1.default.ListFormat.SourceFileStatements, typescript_1.default.factory.createNodeArray(tsNodes), file);
    const vHost = new VirtualCompilerHost_1.VirtualCompilerHost({
        declaration: false,
    });
    vHost.addFile("phero-execution.ts", tsPheroExecution);
    const prog = vHost.createProgram("phero-execution.ts");
    prog.emit();
    // console.log(vHost.getFile("phero-execution.ts"))
    const js = vHost.getFile("phero-execution.js");
    if (!js) {
        throw new Error("Some error in generated TS.");
    }
    return { js };
}
exports.default = generateRPCProxy;
function generateCorsConfigFunction(service) {
    return tsx.function({
        export: true,
        async: true,
        name: `service_cors_config__${service.name}`,
        returnType: tsx.type.reference({
            name: "Promise",
            args: [tsx.type.array(tsx.type.string)],
        }),
        params: [],
        body: [
            tsx.statement.return(tsx.expression.propertyAccess(service.name, "config", "cors")),
        ],
    });
}
function generateRPCExecutor(service, funcDef, domainErrors, typeChecker) {
    return tsx.function({
        export: true,
        async: true,
        name: `rpc_executor_${service.name}__${funcDef.name}`,
        params: [tsx.param({ name: "input", type: tsx.type.any })],
        returnType: tsx.type.reference({
            name: "Promise",
            args: [tsx.type.reference({ name: "RPCResult", args: [tsx.type.any] })],
        }),
        body: tsx.block(wrapWithErrorHandler(service, domainErrors, tsx.const({
            name: "result",
            init: tsx.expression.await(tsx.expression.call(`rpc_executor_${service.name}__${funcDef.name}__inner`, { args: ["input"] })),
        }), tsx.statement.return(tsx.literal.object(tsx.property.assignment("status", tsx.literal.number(200)), tsx.property.shorthandAssignment("result"))))),
    });
}
function generateInnerFunction(service, funcDef, typeChecker) {
    var _a, _b, _c, _d;
    return tsx.function({
        name: `rpc_executor_${service.name}__${funcDef.name}__inner`,
        params: [
            tsx.param({
                name: "input",
                type: tsx.type.any,
            }),
        ],
        returnType: tsx.type.reference({
            name: "Promise",
            args: [tsx.type.any],
        }),
        body: tsx.block(tsx.const({
            name: "runner",
            init: tsx.arrowFunction({
                async: true,
                params: [
                    tsx.param({
                        name: "resolveEXEC",
                        type: tsx.type.any,
                    }),
                    tsx.param({
                        name: "rejectEXEC",
                        type: tsx.type.any,
                    }),
                ],
                body: tsx.block(tsx.const({
                    name: "inputParser",
                    init: generateInlineParser({
                        returnType: tsx.type.any,
                        parser: (0, generateParserFromModel_1.default)((0, generateParserModel_1.default)(typeChecker, funcDef.actualFunction, "data")),
                    }),
                }), tsx.const({
                    name: "outputParser",
                    init: generateInlineParser({
                        returnType: tsx.type.any,
                        parser: (0, generateParserFromModel_1.default)((0, generateParserModel_1.default)(typeChecker, (0, parseReturnType_1.default)(funcDef.actualFunction), "data")),
                    }),
                }), ...(service.config.middleware
                    ? [
                        tsx.const({
                            name: "resolvers",
                            init: tsx.literal.array(
                            // for middleware
                            ...service.config.middleware.map((middleware) => {
                                var _a;
                                return tsx.literal.object(tsx.property.assignment("inputContext", tsx.expression.call("defer", {
                                    typeArgs: [
                                        (_a = middleware.contextType) !== null && _a !== void 0 ? _a : tsx.literal.type(),
                                    ],
                                })), tsx.property.assignment("exec", tsx.expression.call("defer")));
                            }), 
                            // for the actual function
                            tsx.literal.object(tsx.property.assignment("inputContext", tsx.expression.call("defer", {
                                typeArgs: [
                                    (_a = service.config.contextType) !== null && _a !== void 0 ? _a : tsx.type.void,
                                ],
                            })), tsx.property.assignment("exec", tsx.expression.call("defer")))),
                        }),
                        ...Array.from({
                            length: service.config.middleware.length + 1,
                        }).map((x, index) => tsx.statement.expression(
                        // resolvers[2].exec.promise.catch(rejectEXEC)
                        tsx.expression.call(tsx.expression.propertyAccess(tsx.expression.elementAccess("resolvers", index), "exec", "promise", "catch"), { args: ["rejectEXEC"] }))),
                        tsx.const({
                            name: "middlewarePromises",
                            init: tsx.literal.array(),
                            type: tsx.type.array(tsx.type.reference({
                                name: "Promise",
                                args: [tsx.type.void],
                            })),
                        }),
                        tsx.statement.expression(tsx.expression.call(tsx.expression.propertyAccess(tsx.expression.elementAccess("resolvers", 0), "inputContext", "resolve"), {
                            args: [
                                tsx.expression.propertyAccess("input", (_c = (_b = funcDef.serviceContext) === null || _b === void 0 ? void 0 : _b.paramName) !== null && _c !== void 0 ? _c : "context"),
                            ],
                        })),
                        // for loop
                        tsx.statement.simpleForOver({
                            name: tsx.expression.propertyAccess(service.name, "config", "middleware"),
                            block: [
                                tsx.const({
                                    name: "middleware",
                                    init: tsx.expression.elementAccess(tsx.expression.propertyAccess(service.name, "config", "middleware"), "i"),
                                }),
                                tsx.const({
                                    name: "parseMiddlewareParams",
                                    init: tsx.expression.elementAccess(tsx.expression.elementAccess(`service_middlewares_${service.name}`, "i"), 0),
                                }),
                                tsx.const({
                                    name: "parseMiddlewareContext",
                                    init: tsx.expression.elementAccess(tsx.expression.elementAccess(`service_middlewares_${service.name}`, "i"), 1),
                                }),
                                tsx.const({
                                    name: "parseMiddlewareNextOut",
                                    init: tsx.expression.elementAccess(tsx.expression.elementAccess(`service_middlewares_${service.name}`, "i"), 2),
                                }),
                                tsx.const({
                                    name: "currResolverIndex",
                                    init: tsx.expression.identifier("i"),
                                }),
                                tsx.const({
                                    name: "nextResolverIndex",
                                    init: tsx.expression.binary(tsx.expression.identifier("i"), "+", tsx.literal.number(1)),
                                }),
                                // const ctx = await resolvers[currResolverIndex].inputContext.promise
                                tsx.const({
                                    name: "ctx",
                                    init: tsx.expression.await(tsx.expression.propertyAccess(tsx.expression.elementAccess("resolvers", "currResolverIndex"), "inputContext", "promise")),
                                }),
                                // const parsedContext = parseMiddlewareContext(i, ctx)
                                tsx.const({
                                    name: "parsedContextParseResult",
                                    init: tsx.expression.call("parseMiddlewareContext", {
                                        args: ["ctx"],
                                    }),
                                }),
                                generateIfParseResultNotOkayEarlyReturn({
                                    parseResult: "parsedContextParseResult",
                                    input: "ctx",
                                }),
                                tsx.const({
                                    name: "parsedContext",
                                    init: tsx.expression.propertyAccess("parsedContextParseResult", "result"),
                                }),
                                // const parsedParams = parseMiddlewareParams(i, ctx)
                                tsx.const({
                                    name: "parsedParamsParseResult",
                                    init: tsx.expression.call("parseMiddlewareParams", {
                                        args: ["input"],
                                    }),
                                }),
                                generateIfParseResultNotOkayEarlyReturn({
                                    parseResult: "parsedParamsParseResult",
                                    input: "input",
                                }),
                                tsx.const({
                                    name: "parsedParams",
                                    init: tsx.expression.propertyAccess("parsedParamsParseResult", "result"),
                                }),
                                tsx.const({
                                    name: "middlewarePromise",
                                    init: tsx.expression.call(tsx.expression.propertyAccess(tsx.expression.call(tsx.expression.propertyAccess(tsx.expression.call("middleware", {
                                        args: [
                                            "parsedParams",
                                            "parsedContext",
                                            tsx.arrowFunction({
                                                async: true,
                                                params: [
                                                    tsx.param({
                                                        name: "nextOutput",
                                                        type: tsx.type.any,
                                                    }),
                                                ],
                                                body: [
                                                    // const parsedOut = parseMiddlewareNextOut(i, nextOutput)
                                                    tsx.const({
                                                        name: "parsedOutParseResult",
                                                        init: tsx.expression.ternary(tsx.expression.binary(tsx.expression.identifier("parseMiddlewareNextOut"), "!=", tsx.literal.null), tsx.expression.call("parseMiddlewareNextOut", { args: ["nextOutput"] }), tsx.literal.object(tsx.property.assignment("ok", tsx.literal.true), tsx.property.assignment("result", tsx.literal.object()))),
                                                    }),
                                                    // generateIfParseResultNotOkayEarlyReturn({
                                                    //   parseResult: "parsedOutParseResult",
                                                    // }),
                                                    tsx.statement.if({
                                                        expression: tsx.expression.binary(tsx.expression.propertyAccess("parsedOutParseResult", "ok"), "===", tsx.literal.false),
                                                        then: tsx.block(tsx.statement.expression(tsx.expression.call(tsx.expression.propertyAccess(tsx.expression.elementAccess("resolvers", "nextResolverIndex"), "inputContext", "reject"), {
                                                            args: [
                                                                tsx.expression.new("ContextParseError", {
                                                                    args: [
                                                                        tsx.expression.propertyAccess("parsedOutParseResult", "errors"),
                                                                    ],
                                                                }),
                                                            ],
                                                        })), tsx.statement.return()),
                                                    }),
                                                    tsx.const({
                                                        name: "parsedOut",
                                                        init: tsx.expression.propertyAccess("parsedOutParseResult", "result"),
                                                    }),
                                                    // resolvers[nextResolverIndex].inputContext.resolve(
                                                    //   {
                                                    //     ...ctx,
                                                    //     ...parsedOut,
                                                    //   },
                                                    // ),
                                                    tsx.statement.expression(tsx.expression.call(tsx.expression.propertyAccess(tsx.expression.elementAccess("resolvers", "nextResolverIndex"), "inputContext", "resolve"), {
                                                        args: [
                                                            tsx.literal.object(tsx.property.spreadAssignment("ctx"), tsx.property.spreadAssignment("parsedOut")),
                                                        ],
                                                    })),
                                                    // await resolvers[nextResolverIndex].exec.promise
                                                    tsx.statement.expression(tsx.expression.await(tsx.expression.propertyAccess(tsx.expression.elementAccess("resolvers", "nextResolverIndex"), "exec", "promise"))),
                                                ],
                                            }),
                                        ],
                                    }), "then"), {
                                        args: [
                                            tsx.arrowFunction({
                                                params: [],
                                                body: [
                                                    // resolvers[currResolverIndex].exec.resolve()
                                                    tsx.statement.expression(tsx.expression.call(tsx.expression.propertyAccess(tsx.expression.elementAccess("resolvers", "currResolverIndex"), "exec", "resolve"))),
                                                ],
                                            }),
                                        ],
                                    }), "catch"), {
                                        args: [
                                            tsx.arrowFunction({
                                                params: [
                                                    tsx.param({
                                                        name: "err",
                                                        type: tsx.type.reference({
                                                            name: "Error",
                                                        }),
                                                    }),
                                                ],
                                                body: [
                                                    // resolvers[currResolverIndex].exec.reject(err)
                                                    tsx.statement.expression(tsx.expression.call(tsx.expression.propertyAccess(tsx.expression.elementAccess("resolvers", "currResolverIndex"), "exec", "reject"), {
                                                        args: ["err"],
                                                    })),
                                                ],
                                            }),
                                        ],
                                    }),
                                }),
                                tsx.statement.expression(tsx.expression.call(tsx.expression.propertyAccess("middlewarePromises", "push"), {
                                    args: ["middlewarePromise"],
                                })),
                            ],
                        }),
                        tsx.const({
                            name: "middlewareOutput",
                            init: tsx.expression.await(tsx.expression.propertyAccess(tsx.expression.elementAccess("resolvers", service.config.middleware.length), "inputContext", "promise")),
                        }),
                        tsx.const({
                            name: "inputWithContext",
                            init: tsx.literal.object(...(((_d = funcDef.serviceContext) === null || _d === void 0 ? void 0 : _d.paramName)
                                ? [
                                    tsx.property.spreadAssignment("input"),
                                    tsx.property.assignment(funcDef.serviceContext.paramName, tsx.expression.identifier("middlewareOutput")),
                                ]
                                : [tsx.property.spreadAssignment("input")])),
                        }),
                        tsx.const({
                            name: "inputParseResult",
                            init: tsx.expression.call("inputParser", {
                                args: ["inputWithContext"],
                            }),
                        }),
                    ]
                    : [
                        tsx.const({
                            name: "inputParseResult",
                            init: tsx.expression.call("inputParser", {
                                args: ["input"],
                            }),
                        }),
                    ]), generateIfParseResultNotOkayEarlyReturn({
                    parseResult: "inputParseResult",
                    input: "input",
                }), generateRPCFunctionCall({ service, funcDef })),
            }),
        }), tsx.statement.return(tsx.expression.new("Promise", {
            args: [
                tsx.arrowFunction({
                    params: [
                        tsx.param({ name: "resolve", type: tsx.type.any }),
                        tsx.param({ name: "reject", type: tsx.type.any }),
                    ],
                    body: [
                        tsx.statement.expression(tsx.expression.call(tsx.expression.propertyAccess(tsx.expression.call(tsx.expression.propertyAccess(tsx.expression.call("runner", {
                            args: ["resolve", "reject"],
                        }), "then"), { args: ["resolve"] }), "catch"), { args: ["reject"] })),
                    ],
                }),
            ],
        }))),
    });
}
function wrapWithErrorHandler(service, domainErrors, ...statements) {
    return tsx.statement.try({
        block: statements,
        catch: {
            error: "error",
            block: [
                generateErrorParsingFunction(service.name, domainErrors, service.errors),
            ],
        },
    });
}
function generateInlineParser({ returnType, parser, }) {
    return tsx.arrowFunction({
        params: [tsx.param({ name: "data", type: tsx.type.any })],
        returnType: tsx.type.reference({
            name: "ParseResult",
            args: [returnType],
        }),
        body: (0, generateParser_1.generateParserBody)(returnType, parser),
    });
}
exports.generateInlineParser = generateInlineParser;
function generateRPCFunctionCall({ service, funcDef, }) {
    var _a;
    return tsx.block(tsx.const({
        name: "output",
        init: tsx.expression.await(tsx.expression.call(tsx.expression.propertyAccess(service.name, "functions", funcDef.name), {
            args: [
                ...funcDef.parameters.map((param) => tsx.expression.propertyAccess("inputParseResult", "result", getParameterName(param.name))),
            ],
        })),
    }), ...(((_a = service.config.middleware) === null || _a === void 0 ? void 0 : _a.length)
        ? [
            // resolvers[3].exec.resolve()
            tsx.statement.expression(tsx.expression.call(tsx.expression.propertyAccess(tsx.expression.elementAccess("resolvers", service.config.middleware.length), "exec", "resolve"))),
            // await Promise.all(middlewarePromises);
            tsx.statement.expression(tsx.expression.await(tsx.expression.call(tsx.expression.propertyAccess("Promise", "all"), { args: ["middlewarePromises"] }))),
        ]
        : []), tsx.const({
        name: "outputParseResult",
        init: tsx.expression.call("outputParser", { args: ["output"] }),
    }), generateIfParseResultNotOkayEarlyReturn({
        parseResult: "outputParseResult",
        input: "output",
    }), generateReturnOkay());
}
function generateErrorParsingFunction(serviceName, domainErrors, serviceErrors) {
    function wrapErrorWithStatusObject(errorObj) {
        return tsx.literal.object(tsx.property.assignment("status", tsx.literal.number(500)), tsx.property.assignment("error", errorObj));
    }
    const fallbackSt = tsx.statement.if({
        expression: tsx.expression.binary(tsx.expression.identifier("error"), "instanceof", tsx.expression.identifier("ContextParseError")),
        then: tsx.block(tsx.statement.return(tsx.literal.object(tsx.property.assignment("status", tsx.literal.number(400)), tsx.property.assignment("input", tsx.expression.propertyAccess("error", "input")), tsx.property.assignment("errors", tsx.expression.propertyAccess("error", "errors"))))),
        else: tsx.statement.if({
            expression: tsx.expression.propertyAccess(tsx.expression.identifier("error?"), "message"),
            then: tsx.statement.return(wrapErrorWithStatusObject(tsx.literal.object(tsx.property.assignment("name", tsx.literal.string("Error")), tsx.property.assignment("props", tsx.literal.object(tsx.property.assignment("message", tsx.expression.propertyAccess("error", "message")))), tsx.property.assignment("stack", tsx.expression.propertyAccess("error", "stack"))))),
            else: tsx.statement.return(wrapErrorWithStatusObject(tsx.literal.object(tsx.property.assignment("name", tsx.literal.string("Error")), tsx.property.assignment("props", tsx.literal.object(tsx.property.assignment("message", tsx.literal.string("Internal Server Error")))), tsx.property.assignment("stack", tsx.expression.propertyAccess("error", "stack"))))),
        }),
    });
    const errors = [
        ...domainErrors.map((error) => ({
            clientName: tsx.literal.string(error.name),
            error,
        })),
        ...serviceErrors.map((error) => ({
            clientName: tsx.literal.string(`${serviceName}.${error.name}`),
            error,
        })),
    ];
    return errors.reduceRight((elseSt, { clientName, error }) => {
        return tsx.statement.if({
            expression: tsx.expression.binary(tsx.expression.binary(tsx.expression.identifier("error"), "instanceof", tsx.expression.identifier("Error")), "&&", tsx.expression.binary(tsx.expression.propertyAccess("error", "constructor", "name"), "==", tsx.literal.string(error.name))),
            then: tsx.statement.return(wrapErrorWithStatusObject(tsx.literal.object(tsx.property.assignment("name", clientName), tsx.property.assignment("props", tsx.literal.object(...error.properties.map((prop) => tsx.property.assignment(prop.name, tsx.expression.propertyAccess("error", prop.name))))), tsx.property.assignment("stack", tsx.expression.propertyAccess("error", "stack"))))),
            else: elseSt,
        });
    }, fallbackSt);
}
function generateIfParseResultNotOkayEarlyReturn({ parseResult, input, }) {
    return tsx.statement.if({
        expression: tsx.expression.binary(tsx.expression.propertyAccess(parseResult, "ok"), "===", tsx.literal.false),
        then: tsx.statement.block(tsx.statement.expression(tsx.expression.call("rejectEXEC", {
            args: [
                tsx.expression.new("ContextParseError", {
                    args: [
                        tsx.expression.propertyAccess(parseResult, "errors"),
                        tsx.expression.identifier(input),
                    ],
                }),
            ],
        })), tsx.statement.return()),
    });
}
function generateReturnOkay() {
    return tsx.statement.expression(tsx.expression.call("resolveEXEC", {
        args: [tsx.expression.propertyAccess("outputParseResult", "result")],
    }));
}
function getParameterName(name) {
    if (typescript_1.default.isIdentifier(name)) {
        return name.text;
    }
    else if (typescript_1.default.isBindingName(name)) {
        throw new __1.ParseError(`S138: No support for binding names ${(0, tsTestUtils_1.printCode)(name)}`, name);
    }
    throw new __1.ParseError("S139: Name not supported", name);
}
const types = [
    tsx.typeAlias({
        name: "ParseResult",
        typeParameters: [tsx.typeParam({ name: "T" })],
        type: tsx.type.union(tsx.type.reference({
            name: "ParseResultSuccess",
            args: [tsx.type.reference({ name: "T" })],
        }), tsx.type.reference({ name: "ParseResultFailure" })),
    }),
    tsx.interface({
        name: "ParseResultSuccess",
        typeParameters: [tsx.typeParam({ name: "T" })],
        members: [
            tsx.property.signature("ok", tsx.type.literalType(tsx.literal.true)),
            tsx.property.signature("result", tsx.type.reference({ name: "T" })),
        ],
    }),
    tsx.interface({
        name: "ParseResultFailure",
        members: [
            tsx.property.signature("ok", tsx.type.literalType(tsx.literal.false)),
            tsx.property.signature("errors", tsx.type.array(tsx.type.reference({ name: "ValidationError" }))),
        ],
    }),
    tsx.interface({
        name: "ValidationError",
        members: [
            tsx.property.signature("path", tsx.type.string),
            tsx.property.signature("message", tsx.type.string),
        ],
    }),
    factory.createTypeAliasDeclaration(undefined, factory.createIdentifier("RPCResult"), [
        factory.createTypeParameterDeclaration(undefined, factory.createIdentifier("T"), undefined, undefined),
    ], factory.createUnionTypeNode([
        factory.createTypeReferenceNode(factory.createIdentifier("RPCOkResult"), [
            factory.createTypeReferenceNode(factory.createIdentifier("T"), undefined),
        ]),
        factory.createTypeReferenceNode(factory.createIdentifier("RPCBadRequestResult"), undefined),
        factory.createTypeReferenceNode(factory.createIdentifier("RPCInternalServerErrorResult"), undefined),
    ])),
    factory.createInterfaceDeclaration(undefined, factory.createIdentifier("RPCOkResult"), [
        factory.createTypeParameterDeclaration(undefined, factory.createIdentifier("T"), undefined, undefined),
    ], undefined, [
        factory.createPropertySignature(undefined, factory.createIdentifier("status"), undefined, factory.createLiteralTypeNode(factory.createNumericLiteral("200"))),
        factory.createPropertySignature(undefined, factory.createIdentifier("result"), undefined, factory.createTypeReferenceNode(factory.createIdentifier("T"), undefined)),
    ]),
    factory.createInterfaceDeclaration(undefined, factory.createIdentifier("RPCBadRequestResult"), undefined, undefined, [
        factory.createPropertySignature(undefined, factory.createIdentifier("status"), undefined, factory.createLiteralTypeNode(factory.createNumericLiteral("400"))),
        factory.createPropertySignature(undefined, factory.createIdentifier("errors"), undefined, factory.createArrayTypeNode(factory.createTypeReferenceNode(factory.createIdentifier("ValidationError"), undefined))),
    ]),
    factory.createInterfaceDeclaration(undefined, factory.createIdentifier("RPCInternalServerErrorResult"), undefined, undefined, [
        factory.createPropertySignature(undefined, factory.createIdentifier("status"), undefined, factory.createLiteralTypeNode(factory.createNumericLiteral("500"))),
        factory.createPropertySignature(undefined, factory.createIdentifier("error"), undefined, factory.createTypeReferenceNode(factory.createIdentifier("Record"), [
            factory.createKeywordTypeNode(typescript_1.default.SyntaxKind.StringKeyword),
            factory.createKeywordTypeNode(typescript_1.default.SyntaxKind.AnyKeyword),
        ])),
    ]),
];
