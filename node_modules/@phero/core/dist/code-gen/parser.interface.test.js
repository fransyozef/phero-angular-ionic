"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const typescript_1 = __importDefault(require("typescript"));
const tsTestUtils_1 = require("../tsTestUtils");
const generateParser_1 = __importDefault(require("./parsers/generateParser"));
describe("Parsers", () => {
    describe("for an interface", () => {
        test("with no members", () => {
            const { statement: model, typeChecker } = (0, tsTestUtils_1.compileStatement)(`
          interface MyModel {
          }
        `, typescript_1.default.SyntaxKind.InterfaceDeclaration);
            const parserDeclaration = (0, generateParser_1.default)(model, typeChecker);
            expect((0, tsTestUtils_1.printCode)(parserDeclaration)).toMatchSnapshot();
        });
        test("number member", () => {
            const { statement: model, typeChecker } = (0, tsTestUtils_1.compileStatement)(`
          interface MyModel {
            a: number
          }
        `, typescript_1.default.SyntaxKind.InterfaceDeclaration);
            const parserDeclaration = (0, generateParser_1.default)(model, typeChecker);
            expect((0, tsTestUtils_1.printCode)(parserDeclaration)).toMatchSnapshot();
        });
        test("string member", () => {
            const { statement: model, typeChecker } = (0, tsTestUtils_1.compileStatement)(`
          interface MyModel {
            a: string
          }
        `, typescript_1.default.SyntaxKind.InterfaceDeclaration);
            const parserDeclaration = (0, generateParser_1.default)(model, typeChecker);
            expect((0, tsTestUtils_1.printCode)(parserDeclaration)).toMatchSnapshot();
        });
        test("boolean member", () => {
            const { statement: model, typeChecker } = (0, tsTestUtils_1.compileStatement)(`
          interface MyModel {
            a: boolean
          }
        `, typescript_1.default.SyntaxKind.InterfaceDeclaration);
            const parserDeclaration = (0, generateParser_1.default)(model, typeChecker);
            expect((0, tsTestUtils_1.printCode)(parserDeclaration)).toMatchSnapshot();
        });
        test("null member", () => {
            const { statement: model, typeChecker } = (0, tsTestUtils_1.compileStatement)(`
          interface MyModel {
            a: null
          }
        `, typescript_1.default.SyntaxKind.InterfaceDeclaration);
            const parserDeclaration = (0, generateParser_1.default)(model, typeChecker);
            expect((0, tsTestUtils_1.printCode)(parserDeclaration)).toMatchSnapshot();
        });
        test("optional member", () => {
            const { statement: model, typeChecker } = (0, tsTestUtils_1.compileStatement)(`
          interface MyModel {
            a?: string
          }
        `, typescript_1.default.SyntaxKind.InterfaceDeclaration);
            const parserDeclaration = (0, generateParser_1.default)(model, typeChecker);
            expect((0, tsTestUtils_1.printCode)(parserDeclaration)).toMatchSnapshot();
        });
        test("string literal member", () => {
            const { statement: model, typeChecker } = (0, tsTestUtils_1.compileStatement)(`
          interface MyModel {
            a: "aap"
          }
        `, typescript_1.default.SyntaxKind.InterfaceDeclaration);
            const parserDeclaration = (0, generateParser_1.default)(model, typeChecker);
            expect((0, tsTestUtils_1.printCode)(parserDeclaration)).toMatchSnapshot();
        });
        test("number literal member", () => {
            const { statement: model, typeChecker } = (0, tsTestUtils_1.compileStatement)(`
          interface MyModel {
            a: 123
          }
        `, typescript_1.default.SyntaxKind.InterfaceDeclaration);
            const parserDeclaration = (0, generateParser_1.default)(model, typeChecker);
            expect((0, tsTestUtils_1.printCode)(parserDeclaration)).toMatchSnapshot();
        });
        test("true literal member", () => {
            const { statement: model, typeChecker } = (0, tsTestUtils_1.compileStatement)(`
          interface MyModel {
            a: true
          }
        `, typescript_1.default.SyntaxKind.InterfaceDeclaration);
            const parserDeclaration = (0, generateParser_1.default)(model, typeChecker);
            expect((0, tsTestUtils_1.printCode)(parserDeclaration)).toMatchSnapshot();
        });
        test("string array member", () => {
            const { statement: model, typeChecker } = (0, tsTestUtils_1.compileStatement)(`
          interface MyModel {
            a: string[]
          }
        `, typescript_1.default.SyntaxKind.InterfaceDeclaration);
            const parserDeclaration = (0, generateParser_1.default)(model, typeChecker);
            expect((0, tsTestUtils_1.printCode)(parserDeclaration)).toMatchSnapshot();
        });
        test("optional string array member", () => {
            const { statement: model, typeChecker } = (0, tsTestUtils_1.compileStatement)(`
          interface MyModel {
            a?: string[]
          }
        `, typescript_1.default.SyntaxKind.InterfaceDeclaration);
            const parserDeclaration = (0, generateParser_1.default)(model, typeChecker);
            expect((0, tsTestUtils_1.printCode)(parserDeclaration)).toMatchSnapshot();
        });
        test("number array member", () => {
            const { statement: model, typeChecker } = (0, tsTestUtils_1.compileStatement)(`
          interface MyModel {
            a: number[]
          }
        `, typescript_1.default.SyntaxKind.InterfaceDeclaration);
            const parserDeclaration = (0, generateParser_1.default)(model, typeChecker);
            expect((0, tsTestUtils_1.printCode)(parserDeclaration)).toMatchSnapshot();
        });
        test("boolean array member", () => {
            const { statement: model, typeChecker } = (0, tsTestUtils_1.compileStatement)(`
          interface MyModel {
            a: boolean[]
          }
        `, typescript_1.default.SyntaxKind.InterfaceDeclaration);
            const parserDeclaration = (0, generateParser_1.default)(model, typeChecker);
            expect((0, tsTestUtils_1.printCode)(parserDeclaration)).toMatchSnapshot();
        });
        test("object literal member", () => {
            const { statement: model, typeChecker } = (0, tsTestUtils_1.compileStatement)(`
          interface MyModel {
            a: {
              b: number
            }
          }
        `, typescript_1.default.SyntaxKind.InterfaceDeclaration);
            const parserDeclaration = (0, generateParser_1.default)(model, typeChecker);
            expect((0, tsTestUtils_1.printCode)(parserDeclaration)).toMatchSnapshot();
        });
        test("object literal array member", () => {
            const { statement: model, typeChecker } = (0, tsTestUtils_1.compileStatement)(`
          interface MyModel {
            a: {
              b: number
            }[]
          }
        `, typescript_1.default.SyntaxKind.InterfaceDeclaration);
            const parserDeclaration = (0, generateParser_1.default)(model, typeChecker);
            expect((0, tsTestUtils_1.printCode)(parserDeclaration)).toMatchSnapshot();
        });
        test("optional object literal member", () => {
            const { statement: model, typeChecker } = (0, tsTestUtils_1.compileStatement)(`
          interface MyModel {
            a?: {
              b: number
            }
          }
        `, typescript_1.default.SyntaxKind.InterfaceDeclaration);
            const parserDeclaration = (0, generateParser_1.default)(model, typeChecker);
            expect((0, tsTestUtils_1.printCode)(parserDeclaration)).toMatchSnapshot();
        });
        test("optional object literal with optional member", () => {
            const { statement: model, typeChecker } = (0, tsTestUtils_1.compileStatement)(`
          interface MyModel {
            a?: {
              b?: number
            }
          }
        `, typescript_1.default.SyntaxKind.InterfaceDeclaration);
            const parserDeclaration = (0, generateParser_1.default)(model, typeChecker);
            expect((0, tsTestUtils_1.printCode)(parserDeclaration)).toMatchSnapshot();
        });
        test("deep nested object", () => {
            const { statement: model, typeChecker } = (0, tsTestUtils_1.compileStatement)(`
          interface MyModel {
            a: {
              b?: {
                c: {
                  d: {
                    e: {
                      f: boolean[]
                    }
                  }[]
                }
              }
            }[]
          }
        `, typescript_1.default.SyntaxKind.InterfaceDeclaration);
            const parserDeclaration = (0, generateParser_1.default)(model, typeChecker);
            expect((0, tsTestUtils_1.printCode)(parserDeclaration)).toMatchSnapshot();
        });
    });
    test("extend an intersection of two interfaces", () => {
        const { statements: [model], typeChecker, } = (0, tsTestUtils_1.compileStatements)(`
          interface MyModel extends C {
            c: number
          }

          type C = A & B

          interface A {
            a: number
          }
          interface B {
            b: number
          }
        `);
        const parserDeclaration = (0, generateParser_1.default)(model, typeChecker);
        expect((0, tsTestUtils_1.printCode)(parserDeclaration)).toMatchSnapshot();
    });
    test("extend an intersection of two interfaces in namepsace", () => {
        // this is for @phero/client
        const { statements: [model], typeChecker, } = (0, tsTestUtils_1.compileStatements)(`
          interface MyModel extends domain.v_1_0_0.C {
            c: number
          }

          namespace domain.v_1_0_0 {
            export type C = A & B

            interface A {
              a: number
            }
            interface B {
              b: number
            }
          }
        `);
        const parserDeclaration = (0, generateParser_1.default)(model, typeChecker);
        expect((0, tsTestUtils_1.printCode)(parserDeclaration)).toMatchSnapshot();
    });
});
