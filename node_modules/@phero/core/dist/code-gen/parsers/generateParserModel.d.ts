import ts from "typescript";
export declare enum ParserModelType {
    Root = "root",
    String = "string",
    StringLiteral = "string-literal",
    Number = "number",
    NumberLiteral = "number-literal",
    Boolean = "boolean",
    BooleanLiteral = "boolean-literal",
    Null = "null",
    Undefined = "undefined",
    Void = "void",
    Object = "object",
    Member = "member",
    IndexMember = "indexMember",
    Array = "array",
    ArrayElement = "arrayElement",
    Tuple = "tuple",
    TupleElement = "tupleElement",
    Union = "union",
    Intersection = "intersection",
    Enum = "enum",
    Reference = "reference",
    Date = "date",
    Any = "any",
    TypeParameter = "typeParameter"
}
export declare type ParserModel = RootParserModel | StringParserModel | StringLiteralParserModel | NumberParserModel | NumberLiteralParserModel | BooleanParserModel | BooleanLiteralParserModel | NullParserModel | UndefinedParserModel | VoidParserModel | ObjectParserModel | MemberParserModel | IndexMemberParserModel | ArrayParserModel | ArrayElementParserModel | TupleParserModel | TupleElementParserModel | UnionParserModel | IntersectionParserModel | EnumParserModel | ReferenceParserModel | DateParserModel | AnyParserModel | TypeParameterParserModel;
export interface RootParserModel {
    type: ParserModelType.Root;
    rootTypeParser?: {
        typeName: string;
        baseTypeName: string;
        typeParameters: {
            typeName: string;
            defaultParser?: {
                typeName: string;
                parser: ParserModel;
            };
        }[];
    };
    name: string;
    parser: ParserModel;
}
export interface StringParserModel {
    type: ParserModelType.String;
}
export interface StringLiteralParserModel {
    type: ParserModelType.StringLiteral;
    literal: string;
}
export interface NumberParserModel {
    type: ParserModelType.Number;
}
export interface NumberLiteralParserModel {
    type: ParserModelType.NumberLiteral;
    literal: number;
}
export interface BooleanParserModel {
    type: ParserModelType.Boolean;
}
export interface BooleanLiteralParserModel {
    type: ParserModelType.BooleanLiteral;
    literal: boolean;
}
export interface NullParserModel {
    type: ParserModelType.Null;
}
export interface UndefinedParserModel {
    type: ParserModelType.Undefined;
}
export interface VoidParserModel {
    type: ParserModelType.Void;
}
export interface ObjectParserModel {
    type: ParserModelType.Object;
    members: (MemberParserModel | IndexMemberParserModel)[];
}
export interface MemberParserModel {
    type: ParserModelType.Member;
    name: string;
    optional: boolean;
    parser: ParserModel;
}
export interface IndexMemberParserModel {
    type: ParserModelType.IndexMember;
    keyParser: ParserModel;
    depth: number;
    optional: boolean;
    parser: ParserModel;
}
export interface ArrayParserModel {
    type: ParserModelType.Array;
    depth: number;
    element: ArrayElementParserModel;
}
export interface ArrayElementParserModel {
    type: ParserModelType.ArrayElement;
    depth: number;
    parser: ParserModel;
}
export interface TupleParserModel {
    type: ParserModelType.Tuple;
    elements: TupleElementParserModel[];
}
export interface TupleElementParserModel {
    type: ParserModelType.TupleElement;
    position: number;
    parser: ParserModel;
}
export interface UnionParserModel {
    type: ParserModelType.Union;
    oneOf: ParserModel[];
}
export interface IntersectionParserModel {
    type: ParserModelType.Intersection;
    parsers: ParserModel[];
}
export interface EnumParserModel {
    type: ParserModelType.Enum;
    members: (StringLiteralParserModel | NumberLiteralParserModel)[];
}
export interface ReferenceParserModel {
    type: ParserModelType.Reference;
    typeName: string;
    fullyQualifiedName: {
        base: string;
        typeArgs?: string;
        full: string;
    };
    baseTypeName: string;
    typeArguments: {
        typeName: string;
        fullyQualifiedName?: {
            base: string;
            typeArgs?: string;
            full: string;
        };
        parser: ParserModel;
    }[];
}
export interface DateParserModel {
    type: ParserModelType.Date;
}
export interface AnyParserModel {
    type: ParserModelType.Any;
}
export interface TypeParameterParserModel {
    type: ParserModelType.TypeParameter;
    typeName: string;
    position: number;
    defaultParser?: {
        typeName: string;
        parser: ParserModel;
    };
}
export default function generateParserModel(typeChecker: ts.TypeChecker, rootNode: ts.Node, rootName: string): RootParserModel;
