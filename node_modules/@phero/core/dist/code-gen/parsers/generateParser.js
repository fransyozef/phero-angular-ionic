"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateNonModelParser = exports.getFunctionName = exports.generateParserBody = void 0;
const typescript_1 = __importDefault(require("typescript"));
const errors_1 = require("../../errors");
const parseAppDeclaration_1 = require("../../parseAppDeclaration");
const tsx = __importStar(require("../../tsx"));
const generateParserFromModel_1 = __importDefault(require("./../parsers/generateParserFromModel"));
const generateParserModel_1 = __importDefault(require("./../parsers/generateParserModel"));
const exportModifier = typescript_1.default.factory.createModifier(typescript_1.default.SyntaxKind.ExportKeyword);
const staticModifier = typescript_1.default.factory.createModifier(typescript_1.default.SyntaxKind.StaticKeyword);
function generateModelParser(model, typeChecker) {
    const rootParserModel = (0, generateParserModel_1.default)(typeChecker, model, "data");
    if (!rootParserModel.rootTypeParser) {
        throw new errors_1.ParseError("S141: Expected rootTypeParser", model);
    }
    const parserStatement = (0, generateParserFromModel_1.default)(rootParserModel);
    const parserName = `${rootParserModel.rootTypeParser.baseTypeName}Parser`;
    return typescript_1.default.factory.createClassDeclaration([exportModifier], parserName, undefined, undefined, [
        typescript_1.default.factory.createMethodDeclaration([staticModifier], undefined, "parse", undefined, rootParserModel.rootTypeParser.typeParameters.map((p) => typescript_1.default.factory.createTypeParameterDeclaration(undefined, p.typeName)), [
            typescript_1.default.factory.createParameterDeclaration(undefined, undefined, "data", undefined, typescript_1.default.factory.createKeywordTypeNode(typescript_1.default.SyntaxKind.AnyKeyword), undefined),
            ...rootParserModel.rootTypeParser.typeParameters.map((typeParam, position) => typescript_1.default.factory.createParameterDeclaration(undefined, undefined, typescript_1.default.factory.createIdentifier(`t${position}`), typeParam.defaultParser
                ? typescript_1.default.factory.createToken(typescript_1.default.SyntaxKind.QuestionToken)
                : undefined, typescript_1.default.factory.createFunctionTypeNode(undefined, [
                typescript_1.default.factory.createParameterDeclaration(undefined, undefined, typescript_1.default.factory.createIdentifier("data"), undefined, typescript_1.default.factory.createKeywordTypeNode(typescript_1.default.SyntaxKind.AnyKeyword), undefined),
            ], typescript_1.default.factory.createTypeReferenceNode(typescript_1.default.factory.createIdentifier("ParseResult"), [
                typescript_1.default.factory.createTypeReferenceNode(typescript_1.default.factory.createIdentifier(typeParam.typeName), undefined),
            ])), undefined)),
        ], typescript_1.default.factory.createTypeReferenceNode(typescript_1.default.factory.createIdentifier("ParseResult"), [
            typescript_1.default.factory.createTypeReferenceNode(rootParserModel.rootTypeParser.typeName, undefined),
        ]), generateParserBody(typescript_1.default.factory.createTypeReferenceNode(rootParserModel.rootTypeParser.typeName), parserStatement)),
    ]);
}
exports.default = generateModelParser;
function generateParserBody(returnType, parserStatement) {
    return typescript_1.default.factory.createBlock([
        typescript_1.default.factory.createVariableStatement(undefined, typescript_1.default.factory.createVariableDeclarationList([
            typescript_1.default.factory.createVariableDeclaration(typescript_1.default.factory.createIdentifier("errors"), undefined, typescript_1.default.factory.createArrayTypeNode(typescript_1.default.factory.createTypeReferenceNode(typescript_1.default.factory.createIdentifier("ValidationError"), undefined)), typescript_1.default.factory.createArrayLiteralExpression([], false)),
        ], typescript_1.default.NodeFlags.Const)),
        typescript_1.default.factory.createVariableStatement(undefined, typescript_1.default.factory.createVariableDeclarationList([
            typescript_1.default.factory.createVariableDeclaration(typescript_1.default.factory.createIdentifier("result"), undefined, typescript_1.default.factory.createKeywordTypeNode(typescript_1.default.SyntaxKind.AnyKeyword), undefined),
        ], typescript_1.default.NodeFlags.Let)),
        parserStatement,
        typescript_1.default.factory.createIfStatement(typescript_1.default.factory.createPropertyAccessExpression(typescript_1.default.factory.createIdentifier("errors"), typescript_1.default.factory.createIdentifier("length")), typescript_1.default.factory.createBlock([
            typescript_1.default.factory.createReturnStatement(typescript_1.default.factory.createObjectLiteralExpression([
                typescript_1.default.factory.createPropertyAssignment(typescript_1.default.factory.createIdentifier("ok"), typescript_1.default.factory.createFalse()),
                typescript_1.default.factory.createShorthandPropertyAssignment(typescript_1.default.factory.createIdentifier("errors"), undefined),
            ], true)),
        ], true), undefined),
        typescript_1.default.factory.createReturnStatement(typescript_1.default.factory.createObjectLiteralExpression([
            typescript_1.default.factory.createPropertyAssignment(typescript_1.default.factory.createIdentifier("ok"), typescript_1.default.factory.createTrue()),
            typescript_1.default.factory.createPropertyAssignment(typescript_1.default.factory.createIdentifier("result"), typescript_1.default.factory.createAsExpression(typescript_1.default.factory.createIdentifier("result"), returnType)),
        ], true)),
    ], true);
}
exports.generateParserBody = generateParserBody;
function getFunctionName(name) {
    if (!name) {
        throw new Error(`Function has no name`);
    }
    if (typescript_1.default.isIdentifier(name)) {
        return name.text;
    }
    if (typescript_1.default.isStringLiteral(name)) {
        return name.text;
    }
    throw new errors_1.ParseError(`S142: Function has unsupported name`, name);
}
exports.getFunctionName = getFunctionName;
function generateNonModelParser(type, model, typeChecker, parserName) {
    if ((0, parseAppDeclaration_1.isModel)(model)) {
        throw new errors_1.ParseError("S143: Should not be model", model);
    }
    const rootParserModel = (0, generateParserModel_1.default)(typeChecker, model, "data");
    const parserStatement = (0, generateParserFromModel_1.default)(rootParserModel);
    return tsx.function({
        name: parserName,
        params: [tsx.param({ name: "data", type: tsx.type.any })],
        returnType: tsx.type.reference({
            name: "ParseResult",
            args: [type],
        }),
        body: generateParserBody(type, parserStatement),
    });
}
exports.generateNonModelParser = generateNonModelParser;
