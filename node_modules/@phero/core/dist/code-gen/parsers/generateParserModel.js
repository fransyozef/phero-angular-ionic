"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ParserModelType = void 0;
const typescript_1 = __importDefault(require("typescript"));
const errors_1 = require("../../errors");
const tsTestUtils_1 = require("../../tsTestUtils");
const tsUtils_1 = require("../../tsUtils");
var ParserModelType;
(function (ParserModelType) {
    ParserModelType["Root"] = "root";
    ParserModelType["String"] = "string";
    ParserModelType["StringLiteral"] = "string-literal";
    ParserModelType["Number"] = "number";
    ParserModelType["NumberLiteral"] = "number-literal";
    ParserModelType["Boolean"] = "boolean";
    ParserModelType["BooleanLiteral"] = "boolean-literal";
    ParserModelType["Null"] = "null";
    ParserModelType["Undefined"] = "undefined";
    ParserModelType["Void"] = "void";
    ParserModelType["Object"] = "object";
    ParserModelType["Member"] = "member";
    ParserModelType["IndexMember"] = "indexMember";
    ParserModelType["Array"] = "array";
    ParserModelType["ArrayElement"] = "arrayElement";
    ParserModelType["Tuple"] = "tuple";
    ParserModelType["TupleElement"] = "tupleElement";
    ParserModelType["Union"] = "union";
    ParserModelType["Intersection"] = "intersection";
    ParserModelType["Enum"] = "enum";
    ParserModelType["Reference"] = "reference";
    ParserModelType["Date"] = "date";
    ParserModelType["Any"] = "any";
    ParserModelType["TypeParameter"] = "typeParameter";
})(ParserModelType = exports.ParserModelType || (exports.ParserModelType = {}));
function generateParserModel(typeChecker, rootNode, rootName) {
    var _a, _b, _c, _d, _e, _f;
    const type = typeChecker.getTypeAtLocation(rootNode);
    const typeName = typeChecker.typeToString(type, rootNode, undefined);
    if (typescript_1.default.isInterfaceDeclaration(rootNode)) {
        const heritageReferenceParsers = ((_a = rootNode.heritageClauses) !== null && _a !== void 0 ? _a : [])
            .flatMap((heritageClause) => heritageClause.types)
            .map((heritageType) => generateReferenceParserModel(type, heritageType, 0));
        const objectParser = {
            type: ParserModelType.Object,
            members: rootNode.members.reduce((members, member) => {
                return member.name
                    ? [
                        ...members,
                        {
                            type: ParserModelType.Member,
                            name: getMemberName(member.name),
                            optional: !!member.questionToken,
                            parser: generate(member, 0),
                        },
                    ]
                    : members;
            }, []),
        };
        return {
            type: ParserModelType.Root,
            name: rootName,
            rootTypeParser: {
                baseTypeName: rootNode.name.text,
                typeName,
                typeParameters: (_c = (_b = rootNode.typeParameters) === null || _b === void 0 ? void 0 : _b.map((typeParam) => ({
                    typeName: typeParam.name.text,
                    defaultParser: typeParam.default && {
                        typeName: typeChecker.typeToString(typeChecker.getTypeFromTypeNode(typeParam.default), rootNode, undefined),
                        parser: generate(typeParam.default, 0),
                    },
                }))) !== null && _c !== void 0 ? _c : [],
            },
            parser: heritageReferenceParsers.length
                ? {
                    type: ParserModelType.Intersection,
                    parsers: [...heritageReferenceParsers, objectParser],
                }
                : objectParser,
        };
    }
    else if (typescript_1.default.isTypeAliasDeclaration(rootNode)) {
        return {
            type: ParserModelType.Root,
            name: rootName,
            rootTypeParser: {
                baseTypeName: rootNode.name.text,
                typeName: ((_d = rootNode.typeParameters) === null || _d === void 0 ? void 0 : _d.length)
                    ? typeName
                    : rootNode.name.text,
                typeParameters: (_f = (_e = rootNode.typeParameters) === null || _e === void 0 ? void 0 : _e.map((typeParam) => ({
                    typeName: typeParam.name.text,
                    defaultParser: typeParam.default && {
                        typeName: typeChecker.typeToString(typeChecker.getTypeFromTypeNode(typeParam.default), rootNode, undefined),
                        parser: generate(typeParam.default, 0),
                    },
                }))) !== null && _f !== void 0 ? _f : [],
            },
            parser: generate(rootNode.type, 0),
        };
    }
    else if (typescript_1.default.isFunctionDeclaration(rootNode)) {
        return {
            type: ParserModelType.Root,
            name: rootName,
            parser: {
                type: ParserModelType.Object,
                members: rootNode.parameters.map((param) => {
                    var _a;
                    const paramType = 
                    //  if it's of type PheroContext, we actually want the type arg
                    param.type &&
                        typescript_1.default.isTypeReferenceNode(param.type) &&
                        (0, tsUtils_1.getTypeName)(param.type) === "PheroContext"
                        ? (_a = param.type.typeArguments) === null || _a === void 0 ? void 0 : _a[0]
                        : param.type;
                    if (!paramType) {
                        throw new errors_1.ParseError("S153: Function parameter has no returnType", param);
                    }
                    return {
                        type: ParserModelType.Member,
                        name: getMemberName(param.name),
                        optional: !!param.questionToken,
                        parser: generate(paramType, 0),
                    };
                }),
            },
            // parser: generate(rootNode, 0),
        };
    }
    return {
        type: ParserModelType.Root,
        name: rootName,
        rootTypeParser: {
            typeName,
            baseTypeName: typeName,
            typeParameters: [],
        },
        parser: generate(rootNode, 0),
    };
    function generate(node, depth) {
        var _a, _b, _c, _d, _e, _f, _g;
        if (typescript_1.default.isPropertySignature(node)) {
            if (!node.type) {
                throw new errors_1.ParseError("S154: Property has no type", node);
            }
            return generate(node.type, depth);
        }
        if (typescript_1.default.isTypeNode(node)) {
            switch (node.kind) {
                case typescript_1.default.SyntaxKind.VoidKeyword:
                    return {
                        type: ParserModelType.Void,
                    };
                case typescript_1.default.SyntaxKind.UndefinedKeyword:
                    return {
                        type: ParserModelType.Undefined,
                    };
                case typescript_1.default.SyntaxKind.StringKeyword:
                    return {
                        type: ParserModelType.String,
                    };
                case typescript_1.default.SyntaxKind.NumberKeyword:
                    return {
                        type: ParserModelType.Number,
                    };
                case typescript_1.default.SyntaxKind.BooleanKeyword:
                    return {
                        type: ParserModelType.Boolean,
                    };
                case typescript_1.default.SyntaxKind.AnyKeyword:
                case typescript_1.default.SyntaxKind.UnknownKeyword:
                    return {
                        type: ParserModelType.Any,
                    };
            }
        }
        if (typescript_1.default.isLiteralTypeNode(node)) {
            switch (node.literal.kind) {
                case typescript_1.default.SyntaxKind.NullKeyword:
                    return { type: ParserModelType.Null };
                case typescript_1.default.SyntaxKind.UndefinedKeyword:
                    return { type: ParserModelType.Undefined };
                case typescript_1.default.SyntaxKind.TrueKeyword:
                    return { type: ParserModelType.BooleanLiteral, literal: true };
                case typescript_1.default.SyntaxKind.FalseKeyword:
                    return { type: ParserModelType.BooleanLiteral, literal: false };
                case typescript_1.default.SyntaxKind.NumericLiteral:
                    return {
                        type: ParserModelType.NumberLiteral,
                        literal: parseInt(node.literal.text, 10),
                    };
                case typescript_1.default.SyntaxKind.StringLiteral:
                    return {
                        type: ParserModelType.StringLiteral,
                        literal: node.literal.text,
                    };
            }
        }
        if (typescript_1.default.isArrayTypeNode(node)) {
            return {
                type: ParserModelType.Array,
                depth,
                element: {
                    type: ParserModelType.ArrayElement,
                    depth,
                    parser: generate(node.elementType, depth + 1),
                },
            };
        }
        if (typescript_1.default.isTypeLiteralNode(node)) {
            return {
                type: ParserModelType.Object,
                members: node.members.reduce((members, member) => {
                    if (typescript_1.default.isIndexSignatureDeclaration(member) &&
                        member.parameters.length === 1 &&
                        member.parameters[0].type) {
                        return [
                            ...members,
                            {
                                type: ParserModelType.IndexMember,
                                depth,
                                keyParser: generate(member.parameters[0].type, depth + 1),
                                optional: !!member.questionToken,
                                parser: generate(member.type, depth + 1),
                            },
                        ];
                    }
                    else if (member.name) {
                        return [
                            ...members,
                            {
                                type: ParserModelType.Member,
                                name: getMemberName(member.name),
                                optional: !!member.questionToken,
                                parser: generate(member, depth),
                            },
                        ];
                    }
                    else {
                        return members;
                    }
                }, []),
            };
        }
        if (typescript_1.default.isTupleTypeNode(node)) {
            return {
                type: ParserModelType.Tuple,
                elements: node.elements.map((element, position) => ({
                    type: ParserModelType.TupleElement,
                    position,
                    parser: generate(element, depth),
                })),
            };
        }
        if (typescript_1.default.isUnionTypeNode(node)) {
            return {
                type: ParserModelType.Union,
                oneOf: node.types.map(generate),
            };
        }
        if (typescript_1.default.isIntersectionTypeNode(node)) {
            return {
                type: ParserModelType.Intersection,
                parsers: node.types.map(generate),
            };
        }
        if (typescript_1.default.isTypeReferenceNode(node) &&
            getMemberName(node.typeName) === "Array" &&
            ((_a = node.typeArguments) === null || _a === void 0 ? void 0 : _a.length) === 1) {
            return {
                type: ParserModelType.Array,
                depth,
                element: {
                    type: ParserModelType.ArrayElement,
                    depth,
                    parser: generate(node.typeArguments[0], depth + 1),
                },
            };
        }
        if (typescript_1.default.isEnumDeclaration(node)) {
            return getEnumParser(node);
        }
        if (typescript_1.default.isTypeReferenceNode(node)) {
            const type = typeChecker.getTypeAtLocation(node);
            const declr = (_b = type.symbol) === null || _b === void 0 ? void 0 : _b.valueDeclaration;
            if (declr) {
                if ((0, tsUtils_1.isExternalType)(type) && type.symbol.name === "Date") {
                    return {
                        type: ParserModelType.Date,
                    };
                }
                else if (typescript_1.default.isEnumDeclaration(declr)) {
                    return getEnumParser(declr);
                }
                else if (typescript_1.default.isEnumMember(declr)) {
                    return getEnumParser(declr.parent).members[declr.parent.members.indexOf(declr)];
                }
            }
            // in case there's no actual argument for the TypeParameter
            else if ((type.flags & typescript_1.default.TypeFlags.TypeParameter) ===
                typescript_1.default.TypeFlags.TypeParameter) {
                const defaultType = type.getDefault();
                const defaultTypeNode = defaultType &&
                    typeChecker.typeToTypeNode(defaultType, node, undefined);
                const defaultParser = defaultTypeNode
                    ? {
                        typeName: typeChecker.typeToString(defaultType, node, undefined),
                        parser: generate(defaultTypeNode, depth),
                    }
                    : undefined;
                const declr = (_c = type.symbol.declarations) === null || _c === void 0 ? void 0 : _c[0];
                let position = -1;
                if (declr && typescript_1.default.isTypeParameterDeclaration(declr)) {
                    if (typescript_1.default.isInterfaceDeclaration(declr.parent) ||
                        typescript_1.default.isTypeAliasDeclaration(declr.parent)) {
                        position = (_e = (_d = declr.parent.typeParameters) === null || _d === void 0 ? void 0 : _d.indexOf(declr)) !== null && _e !== void 0 ? _e : -1;
                    }
                    else {
                        throw new errors_1.ParseError("S144: Should be either interface or TypeAlias", declr);
                    }
                }
                return {
                    type: ParserModelType.TypeParameter,
                    typeName: typeChecker.typeToString(type, node, undefined),
                    position,
                    defaultParser,
                };
            }
            else if ((type.flags & typescript_1.default.TypeFlags.Object) === typescript_1.default.TypeFlags.Object) {
                return generateObjectType(type, node, depth);
            }
            else if (type.isUnionOrIntersection()) {
                return generateReferenceParserModel(type, node, depth);
            }
            else {
                // These are TypeReferenceNode's which have no declaration
                // for instance: Partial<Something>
                // When Something has a TypeReference it has no declaration, no symbol, no type.
                const baseTypeName = getMemberName(node.typeName);
                return {
                    type: ParserModelType.Reference,
                    baseTypeName: baseTypeName,
                    typeName: baseTypeName,
                    fullyQualifiedName: (0, tsUtils_1.getFullyQualifiedNameWithBase)(baseTypeName, node, typeChecker),
                    typeArguments: (_g = (_f = node.typeArguments) === null || _f === void 0 ? void 0 : _f.map((typeArg) => ({
                        typeName: typeChecker.typeToString(typeChecker.getTypeFromTypeNode(typeArg)),
                        fullyQualifiedName: typescript_1.default.isTypeReferenceNode(typeArg)
                            ? (0, tsUtils_1.getFullyQualifiedName)(typeArg, typeChecker)
                            : undefined,
                        parser: generate(typeArg, depth),
                    }))) !== null && _g !== void 0 ? _g : [],
                };
            }
        }
        if (typescript_1.default.isParenthesizedTypeNode(node)) {
            return generate(node.type, depth);
        }
        if (typescript_1.default.isMappedTypeNode(node) &&
            node.type &&
            node.typeParameter.constraint) {
            return {
                type: ParserModelType.Object,
                members: [
                    {
                        type: ParserModelType.IndexMember,
                        depth,
                        keyParser: generate(node.typeParameter.constraint, depth + 1),
                        optional: false,
                        parser: generate(node.type, depth + 1),
                    },
                ],
            };
        }
        if (typescript_1.default.isTypeOperatorNode(node) &&
            node.operator === typescript_1.default.SyntaxKind.KeyOfKeyword) {
            const type = typeChecker.getTypeAtLocation(node.type);
            const props = typeChecker.getAugmentedPropertiesOfType(type);
            return {
                type: ParserModelType.Union,
                oneOf: props.map((member) => ({
                    type: ParserModelType.StringLiteral,
                    literal: member.name,
                })),
            };
        }
        if (typescript_1.default.isIndexedAccessTypeNode(node) &&
            typescript_1.default.isLiteralTypeNode(node.indexType) &&
            typescript_1.default.isStringLiteral(node.indexType.literal)) {
            const prop = typeChecker
                .getTypeAtLocation(node.objectType)
                .getProperty(node.indexType.literal.text);
            if (prop === null || prop === void 0 ? void 0 : prop.valueDeclaration) {
                return generate(prop.valueDeclaration, depth);
            }
        }
        throw new errors_1.ParseError(`S145: ParserModel not implemented yet: \`${(0, tsTestUtils_1.printCode)(node)}\` (kind:${node.kind})`, node);
    }
    function generateObjectType(type, node, depth) {
        if ((0, tsUtils_1.isExternalType)(type)) {
            const props = typeChecker.getAugmentedPropertiesOfType(type);
            return {
                type: ParserModelType.Object,
                members: props.reduce((members, member) => {
                    const memberType = typeChecker.getTypeOfSymbolAtLocation(member, node);
                    const actualType = typeChecker.typeToTypeNode(memberType, node, undefined);
                    const optional = (member.flags & typescript_1.default.SymbolFlags.Optional) === typescript_1.default.SymbolFlags.Optional;
                    return member.name && actualType
                        ? [
                            ...members,
                            {
                                type: ParserModelType.Member,
                                name: member.name,
                                optional,
                                parser: generate(actualType, depth),
                            },
                        ]
                        : members;
                }, []),
            };
        }
        return generateReferenceParserModel(type, node, depth);
    }
    function getMemberName(name) {
        if (!name) {
            throw new Error("No member name");
        }
        if (typescript_1.default.isIdentifier(name)) {
            return name.text;
        }
        else if (typescript_1.default.isStringLiteral(name)) {
            return name.text;
        }
        else if (typescript_1.default.isNumericLiteral(name)) {
            return name.text;
        }
        else if (typescript_1.default.isQualifiedName(name)) {
            return name.right.text;
        }
        else if (typescript_1.default.isComputedPropertyName(name)) {
            throw new errors_1.ParseError(`S146: No support for computed names ${(0, tsTestUtils_1.printCode)(name)}`, name);
        }
        else if (typescript_1.default.isPrivateIdentifier(name)) {
            throw new errors_1.ParseError(`S147: No support for private names ${(0, tsTestUtils_1.printCode)(name)}`, name);
        }
        else if (typescript_1.default.isBindingName(name)) {
            throw new errors_1.ParseError(`S148: No support for binding names ${(0, tsTestUtils_1.printCode)(name)}`, name);
        }
        throw new errors_1.ParseError("S149: Name not supported", name);
    }
    function getEnumParser(enumDeclr) {
        let nextUninitializedValue = 0;
        return {
            type: ParserModelType.Enum,
            members: enumDeclr.members.map((member) => {
                if (member.initializer) {
                    if (typescript_1.default.isStringLiteral(member.initializer)) {
                        return {
                            type: ParserModelType.StringLiteral,
                            literal: member.initializer.text,
                        };
                    }
                    else if (typescript_1.default.isNumericLiteral(member.initializer)) {
                        const memberValue = parseInt(member.initializer.text, 10);
                        nextUninitializedValue = memberValue + 1;
                        return {
                            type: ParserModelType.NumberLiteral,
                            literal: memberValue,
                        };
                    }
                    else {
                        throw new errors_1.ParseError("S150: Enum member has unsupported value", enumDeclr);
                    }
                }
                else {
                    return {
                        type: ParserModelType.NumberLiteral,
                        literal: nextUninitializedValue++,
                    };
                }
            }),
        };
    }
    function generateReferenceParserModel(type, node, depth) {
        var _a, _b, _c;
        const baseTypeName = typescript_1.default.isTypeReferenceNode(node)
            ? getMemberName(node.typeName)
            : typescript_1.default.isIdentifier(node.expression)
                ? node.expression.text
                : typescript_1.default.isPropertyAccessExpression(node.expression)
                    ? getMemberName(node.expression.name)
                    : undefined;
        if (!baseTypeName) {
            throw new errors_1.ParseError(`Unexpected expression (${(_a = node === null || node === void 0 ? void 0 : node.expression.kind) !== null && _a !== void 0 ? _a : 0})`, node);
        }
        return {
            type: ParserModelType.Reference,
            baseTypeName,
            typeName: typeChecker.typeToString(type, node, undefined),
            fullyQualifiedName: (0, tsUtils_1.getFullyQualifiedName)(node, typeChecker),
            typeArguments: (_c = (_b = node.typeArguments) === null || _b === void 0 ? void 0 : _b.map((typeArg) => ({
                typeName: typeChecker.typeToString(typeChecker.getTypeFromTypeNode(typeArg)),
                fullyQualifiedName: typescript_1.default.isTypeReferenceNode(typeArg)
                    ? (0, tsUtils_1.getFullyQualifiedName)(typeArg, typeChecker)
                    : undefined,
                parser: generate(typeArg, depth),
            }))) !== null && _c !== void 0 ? _c : [],
        };
    }
}
exports.default = generateParserModel;
