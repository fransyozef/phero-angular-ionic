"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const generateAnyParser_1 = __importDefault(require("./generateAnyParser"));
const generateArrayParser_1 = __importDefault(require("./generateArrayParser"));
const generateBooleanLiteralParser_1 = __importDefault(require("./generateBooleanLiteralParser"));
const generateBooleanParser_1 = __importDefault(require("./generateBooleanParser"));
const generateDateParser_1 = __importDefault(require("./generateDateParser"));
const generateEnumParser_1 = __importDefault(require("./generateEnumParser"));
const generateIndexMemberParser_1 = __importDefault(require("./generateIndexMemberParser"));
const generateIntersectionParser_1 = __importDefault(require("./generateIntersectionParser"));
const generateMemberParser_1 = __importDefault(require("./generateMemberParser"));
const generateNullParser_1 = __importDefault(require("./generateNullParser"));
const generateNumberLiteralParser_1 = __importDefault(require("./generateNumberLiteralParser"));
const generateNumberParser_1 = __importDefault(require("./generateNumberParser"));
const generateObjectParser_1 = __importDefault(require("./generateObjectParser"));
const generateParserModel_1 = require("./generateParserModel");
const generateReferenceParser_1 = __importDefault(require("./generateReferenceParser"));
const generateStringLiteralParser_1 = __importDefault(require("./generateStringLiteralParser"));
const generateStringParser_1 = __importDefault(require("./generateStringParser"));
const generateTupleParser_1 = __importDefault(require("./generateTupleParser"));
const generateTypeParameterParser_1 = __importDefault(require("./generateTypeParameterParser"));
const generateUndefinedParser_1 = __importDefault(require("./generateUndefinedParser"));
const generateUnionParser_1 = __importDefault(require("./generateUnionParser"));
const generateVoidParser_1 = __importDefault(require("./generateVoidParser"));
const Pointer_1 = __importDefault(require("./Pointer"));
function generateParserFromModel(model, ancestors = []) {
    switch (model.type) {
        case generateParserModel_1.ParserModelType.Root:
            return generateParserFromModel(model.parser, [model]);
        case generateParserModel_1.ParserModelType.String:
            return (0, generateStringParser_1.default)(new Pointer_1.default(model, ancestors));
        case generateParserModel_1.ParserModelType.Object:
            return (0, generateObjectParser_1.default)(new Pointer_1.default(model, ancestors));
        case generateParserModel_1.ParserModelType.Member:
            return (0, generateMemberParser_1.default)(new Pointer_1.default(model, ancestors));
        case generateParserModel_1.ParserModelType.IndexMember:
            return (0, generateIndexMemberParser_1.default)(new Pointer_1.default(model, ancestors));
        case generateParserModel_1.ParserModelType.StringLiteral:
            return (0, generateStringLiteralParser_1.default)(new Pointer_1.default(model, ancestors));
        case generateParserModel_1.ParserModelType.Number:
            return (0, generateNumberParser_1.default)(new Pointer_1.default(model, ancestors));
        case generateParserModel_1.ParserModelType.NumberLiteral:
            return (0, generateNumberLiteralParser_1.default)(new Pointer_1.default(model, ancestors));
        case generateParserModel_1.ParserModelType.Boolean:
            return (0, generateBooleanParser_1.default)(new Pointer_1.default(model, ancestors));
        case generateParserModel_1.ParserModelType.BooleanLiteral:
            return (0, generateBooleanLiteralParser_1.default)(new Pointer_1.default(model, ancestors));
        case generateParserModel_1.ParserModelType.Null:
            return (0, generateNullParser_1.default)(new Pointer_1.default(model, ancestors));
        case generateParserModel_1.ParserModelType.Undefined:
            return (0, generateUndefinedParser_1.default)(new Pointer_1.default(model, ancestors));
        case generateParserModel_1.ParserModelType.Void:
            return (0, generateVoidParser_1.default)(new Pointer_1.default(model, ancestors));
        case generateParserModel_1.ParserModelType.Array:
            return (0, generateArrayParser_1.default)(new Pointer_1.default(model, ancestors));
        case generateParserModel_1.ParserModelType.Tuple:
            return (0, generateTupleParser_1.default)(new Pointer_1.default(model, ancestors));
        case generateParserModel_1.ParserModelType.TupleElement:
        case generateParserModel_1.ParserModelType.ArrayElement:
            return generateParserFromModel(model.parser, [...ancestors, model]);
        case generateParserModel_1.ParserModelType.Union:
            return (0, generateUnionParser_1.default)(new Pointer_1.default(model, ancestors));
        case generateParserModel_1.ParserModelType.Intersection:
            return (0, generateIntersectionParser_1.default)(new Pointer_1.default(model, ancestors));
        case generateParserModel_1.ParserModelType.Enum:
            return (0, generateEnumParser_1.default)(new Pointer_1.default(model, ancestors));
        case generateParserModel_1.ParserModelType.Reference:
            return (0, generateReferenceParser_1.default)(new Pointer_1.default(model, ancestors));
        case generateParserModel_1.ParserModelType.Date:
            return (0, generateDateParser_1.default)(new Pointer_1.default(model, ancestors));
        case generateParserModel_1.ParserModelType.Any:
            return (0, generateAnyParser_1.default)(new Pointer_1.default(model, ancestors));
        case generateParserModel_1.ParserModelType.TypeParameter:
            return (0, generateTypeParameterParser_1.default)(new Pointer_1.default(model, ancestors));
    }
}
exports.default = generateParserFromModel;
