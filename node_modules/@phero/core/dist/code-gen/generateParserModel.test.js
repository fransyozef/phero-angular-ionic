"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const typescript_1 = __importDefault(require("typescript"));
const tsTestUtils_1 = require("../tsTestUtils");
const generateParserModel_1 = __importDefault(require("./parsers/generateParserModel"));
describe("generateParserModel", () => {
    describe("for an interface", () => {
        test("with no members", () => {
            const { statement: model, typeChecker } = (0, tsTestUtils_1.compileStatement)(`
          interface MyModel {
          }
        `, typescript_1.default.SyntaxKind.InterfaceDeclaration);
            const parserModel = (0, generateParserModel_1.default)(typeChecker, model, "data");
            expect(parserModel).toMatchSnapshot();
        });
        test("number member", () => {
            const { statement: model, typeChecker } = (0, tsTestUtils_1.compileStatement)(`
          interface MyModel {
            a: number
          }
        `, typescript_1.default.SyntaxKind.InterfaceDeclaration);
            const parserModel = (0, generateParserModel_1.default)(typeChecker, model, "data");
            expect(parserModel).toMatchSnapshot();
        });
        test("string member", () => {
            const { statement: model, typeChecker } = (0, tsTestUtils_1.compileStatement)(`
          interface MyModel {
            a: string
          }
        `, typescript_1.default.SyntaxKind.InterfaceDeclaration);
            const parserModel = (0, generateParserModel_1.default)(typeChecker, model, "data");
            expect(parserModel).toMatchSnapshot();
        });
        test("boolean member", () => {
            const { statement: model, typeChecker } = (0, tsTestUtils_1.compileStatement)(`
          interface MyModel {
            a: boolean
          }
        `, typescript_1.default.SyntaxKind.InterfaceDeclaration);
            const parserModel = (0, generateParserModel_1.default)(typeChecker, model, "data");
            expect(parserModel).toMatchSnapshot();
        });
        test("null member", () => {
            const { statement: model, typeChecker } = (0, tsTestUtils_1.compileStatement)(`
          interface MyModel {
            a: null
          }
        `, typescript_1.default.SyntaxKind.InterfaceDeclaration);
            const parserModel = (0, generateParserModel_1.default)(typeChecker, model, "data");
            expect(parserModel).toMatchSnapshot();
        });
        test("optional member", () => {
            const { statement: model, typeChecker } = (0, tsTestUtils_1.compileStatement)(`
          interface MyModel {
            a?: string
          }
        `, typescript_1.default.SyntaxKind.InterfaceDeclaration);
            const parserModel = (0, generateParserModel_1.default)(typeChecker, model, "data");
            expect(parserModel).toMatchSnapshot();
        });
        test("string literal member", () => {
            const { statement: model, typeChecker } = (0, tsTestUtils_1.compileStatement)(`
          interface MyModel {
            a: "aap"
          }
        `, typescript_1.default.SyntaxKind.InterfaceDeclaration);
            const parserModel = (0, generateParserModel_1.default)(typeChecker, model, "data");
            expect(parserModel).toMatchSnapshot();
        });
        test("number literal member", () => {
            const { statement: model, typeChecker } = (0, tsTestUtils_1.compileStatement)(`
          interface MyModel {
            a: 123
          }
        `, typescript_1.default.SyntaxKind.InterfaceDeclaration);
            const parserModel = (0, generateParserModel_1.default)(typeChecker, model, "data");
            expect(parserModel).toMatchSnapshot();
        });
        test("true literal member", () => {
            const { statement: model, typeChecker } = (0, tsTestUtils_1.compileStatement)(`
          interface MyModel {
            a: true
          }
        `, typescript_1.default.SyntaxKind.InterfaceDeclaration);
            const parserModel = (0, generateParserModel_1.default)(typeChecker, model, "data");
            expect(parserModel).toMatchSnapshot();
        });
        test("string array member", () => {
            const { statement: model, typeChecker } = (0, tsTestUtils_1.compileStatement)(`
          interface MyModel {
            a: string[]
          }
        `, typescript_1.default.SyntaxKind.InterfaceDeclaration);
            const parserModel = (0, generateParserModel_1.default)(typeChecker, model, "data");
            expect(parserModel).toMatchSnapshot();
        });
        test("optional string array member", () => {
            const { statement: model, typeChecker } = (0, tsTestUtils_1.compileStatement)(`
          interface MyModel {
            a?: string[]
          }
        `, typescript_1.default.SyntaxKind.InterfaceDeclaration);
            const parserModel = (0, generateParserModel_1.default)(typeChecker, model, "data");
            expect(parserModel).toMatchSnapshot();
        });
        test("number array member", () => {
            const { statement: model, typeChecker } = (0, tsTestUtils_1.compileStatement)(`
          interface MyModel {
            a: number[]
          }
        `, typescript_1.default.SyntaxKind.InterfaceDeclaration);
            const parserModel = (0, generateParserModel_1.default)(typeChecker, model, "data");
            expect(parserModel).toMatchSnapshot();
        });
        test("boolean array member", () => {
            const { statement: model, typeChecker } = (0, tsTestUtils_1.compileStatement)(`
          interface MyModel {
            a: boolean[]
          }
        `, typescript_1.default.SyntaxKind.InterfaceDeclaration);
            const parserModel = (0, generateParserModel_1.default)(typeChecker, model, "data");
            expect(parserModel).toMatchSnapshot();
        });
        test("object literal member", () => {
            const { statement: model, typeChecker } = (0, tsTestUtils_1.compileStatement)(`
          interface MyModel {
            a: {
              b: number
            }
          }
        `, typescript_1.default.SyntaxKind.InterfaceDeclaration);
            const parserModel = (0, generateParserModel_1.default)(typeChecker, model, "data");
            expect(parserModel).toMatchSnapshot();
        });
        test("object literal array member", () => {
            const { statement: model, typeChecker } = (0, tsTestUtils_1.compileStatement)(`
          interface MyModel {
            a: {
              b: number
            }[]
          }
        `, typescript_1.default.SyntaxKind.InterfaceDeclaration);
            const parserModel = (0, generateParserModel_1.default)(typeChecker, model, "data");
            expect(parserModel).toMatchSnapshot();
        });
        test("optional object literal member", () => {
            const { statement: model, typeChecker } = (0, tsTestUtils_1.compileStatement)(`
          interface MyModel {
            a?: {
              b: number
            }
          }
        `, typescript_1.default.SyntaxKind.InterfaceDeclaration);
            const parserModel = (0, generateParserModel_1.default)(typeChecker, model, "data");
            expect(parserModel).toMatchSnapshot();
        });
        test("optional object literal with optional member", () => {
            const { statement: model, typeChecker } = (0, tsTestUtils_1.compileStatement)(`
          interface MyModel {
            a?: {
              b?: number
            }
          }
        `, typescript_1.default.SyntaxKind.InterfaceDeclaration);
            const parserModel = (0, generateParserModel_1.default)(typeChecker, model, "data");
            expect(parserModel).toMatchSnapshot();
        });
        test("deep nested object", () => {
            const { statement: model, typeChecker } = (0, tsTestUtils_1.compileStatement)(`
          interface MyModel {
            a: {
              b?: {
                c: {
                  d: {
                    e: {
                      f: boolean[]
                    }
                  }[]
                }
              }
            }[]
          }
        `, typescript_1.default.SyntaxKind.InterfaceDeclaration);
            const parserModel = (0, generateParserModel_1.default)(typeChecker, model, "data");
            expect(parserModel).toMatchSnapshot();
        });
    });
    describe("for a type alias", () => {
        describe("object literal", () => {
            test("with no members", () => {
                const { statement: model, typeChecker } = (0, tsTestUtils_1.compileStatement)(`
          type MyModel = {}
        `, typescript_1.default.SyntaxKind.TypeAliasDeclaration);
                const parserModel = (0, generateParserModel_1.default)(typeChecker, model, "data");
                expect(parserModel).toMatchSnapshot();
            });
            test("number member", () => {
                const { statement: model, typeChecker } = (0, tsTestUtils_1.compileStatement)(`
          type MyModel = {
            a: number
          }
        `, typescript_1.default.SyntaxKind.TypeAliasDeclaration);
                const parserModel = (0, generateParserModel_1.default)(typeChecker, model, "data");
                expect(parserModel).toMatchSnapshot();
            });
            test("number model", () => {
                const { statement: model, typeChecker } = (0, tsTestUtils_1.compileStatement)(`
          type MyModel = number
        `, typescript_1.default.SyntaxKind.TypeAliasDeclaration);
                const parserModel = (0, generateParserModel_1.default)(typeChecker, model, "data");
                expect(parserModel).toMatchSnapshot();
            });
            test("string member", () => {
                const { statement: model, typeChecker } = (0, tsTestUtils_1.compileStatement)(`
          type MyModel = {
            a: string
          }
        `, typescript_1.default.SyntaxKind.TypeAliasDeclaration);
                const parserModel = (0, generateParserModel_1.default)(typeChecker, model, "data");
                expect(parserModel).toMatchSnapshot();
            });
            test("boolean member", () => {
                const { statement: model, typeChecker } = (0, tsTestUtils_1.compileStatement)(`
          type MyModel = {
            a: boolean
          }
        `, typescript_1.default.SyntaxKind.TypeAliasDeclaration);
                const parserModel = (0, generateParserModel_1.default)(typeChecker, model, "data");
                expect(parserModel).toMatchSnapshot();
            });
            test("null member", () => {
                const { statement: model, typeChecker } = (0, tsTestUtils_1.compileStatement)(`
          type MyModel = {
            a: null
          }
        `, typescript_1.default.SyntaxKind.TypeAliasDeclaration);
                const parserModel = (0, generateParserModel_1.default)(typeChecker, model, "data");
                expect(parserModel).toMatchSnapshot();
            });
            test("optional member", () => {
                const { statement: model, typeChecker } = (0, tsTestUtils_1.compileStatement)(`
          type MyModel = {
            a?: string
          }
        `, typescript_1.default.SyntaxKind.TypeAliasDeclaration);
                const parserModel = (0, generateParserModel_1.default)(typeChecker, model, "data");
                expect(parserModel).toMatchSnapshot();
            });
            test("string literal member", () => {
                const { statement: model, typeChecker } = (0, tsTestUtils_1.compileStatement)(`
          type MyModel = {
            a: "xxx"
          }
        `, typescript_1.default.SyntaxKind.TypeAliasDeclaration);
                const parserModel = (0, generateParserModel_1.default)(typeChecker, model, "data");
                expect(parserModel).toMatchSnapshot();
            });
            test("number literal member", () => {
                const { statement: model, typeChecker } = (0, tsTestUtils_1.compileStatement)(`
          type MyModel = {
            a: 123
          }
        `, typescript_1.default.SyntaxKind.TypeAliasDeclaration);
                const parserModel = (0, generateParserModel_1.default)(typeChecker, model, "data");
                expect(parserModel).toMatchSnapshot();
            });
            test("true literal member", () => {
                const { statement: model, typeChecker } = (0, tsTestUtils_1.compileStatement)(`
          type MyModel = {
            a: true
          }
        `, typescript_1.default.SyntaxKind.TypeAliasDeclaration);
                const parserModel = (0, generateParserModel_1.default)(typeChecker, model, "data");
                expect(parserModel).toMatchSnapshot();
            });
            test("string array member", () => {
                const { statement: model, typeChecker } = (0, tsTestUtils_1.compileStatement)(`
          type MyModel = {
            a: string[]
          }
        `, typescript_1.default.SyntaxKind.TypeAliasDeclaration);
                const parserModel = (0, generateParserModel_1.default)(typeChecker, model, "data");
                expect(parserModel).toMatchSnapshot();
            });
            test("optional string array member", () => {
                const { statement: model, typeChecker } = (0, tsTestUtils_1.compileStatement)(`
          type MyModel = {
            a?: string[]
          }
        `, typescript_1.default.SyntaxKind.TypeAliasDeclaration);
                const parserModel = (0, generateParserModel_1.default)(typeChecker, model, "data");
                expect(parserModel).toMatchSnapshot();
            });
            test("number array member", () => {
                const { statement: model, typeChecker } = (0, tsTestUtils_1.compileStatement)(`
          type MyModel = {
            a: number[]
          }
        `, typescript_1.default.SyntaxKind.TypeAliasDeclaration);
                const parserModel = (0, generateParserModel_1.default)(typeChecker, model, "data");
                expect(parserModel).toMatchSnapshot();
            });
            test("boolean array member", () => {
                const { statement: model, typeChecker } = (0, tsTestUtils_1.compileStatement)(`
          type MyModel = {
            a: boolean[]
          }
        `, typescript_1.default.SyntaxKind.TypeAliasDeclaration);
                const parserModel = (0, generateParserModel_1.default)(typeChecker, model, "data");
                expect(parserModel).toMatchSnapshot();
            });
            test("object literal member", () => {
                const { statement: model, typeChecker } = (0, tsTestUtils_1.compileStatement)(`
          type MyModel = {
            a: {b: number}[]
          }
        `, typescript_1.default.SyntaxKind.TypeAliasDeclaration);
                const parserModel = (0, generateParserModel_1.default)(typeChecker, model, "data");
                expect(parserModel).toMatchSnapshot();
            });
            test("optional object literal member", () => {
                const { statement: model, typeChecker } = (0, tsTestUtils_1.compileStatement)(`
          type MyModel = {
            a?: {b: number}[]
          }
        `, typescript_1.default.SyntaxKind.TypeAliasDeclaration);
                const parserModel = (0, generateParserModel_1.default)(typeChecker, model, "data");
                expect(parserModel).toMatchSnapshot();
            });
            test("optional object literal with optional member", () => {
                const { statement: model, typeChecker } = (0, tsTestUtils_1.compileStatement)(`
          type MyModel = {
            a?: {
              b?: number
            }
          }
        `, typescript_1.default.SyntaxKind.TypeAliasDeclaration);
                const parserModel = (0, generateParserModel_1.default)(typeChecker, model, "data");
                expect(parserModel).toMatchSnapshot();
            });
            test("deep nested object", () => {
                const { statement: model, typeChecker } = (0, tsTestUtils_1.compileStatement)(`
          type MyModel = {
            a: {
              b?: {c: { d?: number }}[]
            }
          }
        `, typescript_1.default.SyntaxKind.TypeAliasDeclaration);
                const parserModel = (0, generateParserModel_1.default)(typeChecker, model, "data");
                expect(parserModel).toMatchSnapshot();
            });
        });
        describe("tuple", () => {
            test("simple", () => {
                const { statement: model, typeChecker } = (0, tsTestUtils_1.compileStatement)(`
          type MyModel = [string, number]
        `, typescript_1.default.SyntaxKind.TypeAliasDeclaration);
                const parserModel = (0, generateParserModel_1.default)(typeChecker, model, "data");
                expect(parserModel).toMatchSnapshot();
            });
            test("tuple with typealias", () => {
                const { statement: model, typeChecker } = (0, tsTestUtils_1.compileStatement)(`
          type MyModel = [string, {a: number}]
        `, typescript_1.default.SyntaxKind.TypeAliasDeclaration);
                const parserModel = (0, generateParserModel_1.default)(typeChecker, model, "data");
                expect(parserModel).toMatchSnapshot();
            });
            test("tuple within tuple", () => {
                const { statement: model, typeChecker } = (0, tsTestUtils_1.compileStatement)(`
          type MyModel = [string, [{a: number}, boolean]]
        `, typescript_1.default.SyntaxKind.TypeAliasDeclaration);
                const parserModel = (0, generateParserModel_1.default)(typeChecker, model, "data");
                expect(parserModel).toMatchSnapshot();
            });
        });
        describe("union", () => {
            test("simple", () => {
                const { statement: model, typeChecker } = (0, tsTestUtils_1.compileStatement)(`
          type MyModel = string | number
        `, typescript_1.default.SyntaxKind.TypeAliasDeclaration);
                const parserModel = (0, generateParserModel_1.default)(typeChecker, model, "data");
                expect(parserModel).toMatchSnapshot();
            });
            test("with type literal", () => {
                const { statement: model, typeChecker } = (0, tsTestUtils_1.compileStatement)(`
          type MyModel = string | {a: number}
        `, typescript_1.default.SyntaxKind.TypeAliasDeclaration);
                const parserModel = (0, generateParserModel_1.default)(typeChecker, model, "data");
                expect(parserModel).toMatchSnapshot();
            });
            test("with tuple", () => {
                const { statement: model, typeChecker } = (0, tsTestUtils_1.compileStatement)(`
          type MyModel = string | [{a: number}, string]
        `, typescript_1.default.SyntaxKind.TypeAliasDeclaration);
                const parserModel = (0, generateParserModel_1.default)(typeChecker, model, "data");
                expect(parserModel).toMatchSnapshot();
            });
            test("with tuple", () => {
                const { statement: model, typeChecker } = (0, tsTestUtils_1.compileStatement)(`
          type MyModel = {a: string, b: number} | {a: number, b: string}
        `, typescript_1.default.SyntaxKind.TypeAliasDeclaration);
                const parserModel = (0, generateParserModel_1.default)(typeChecker, model, "data");
                expect(parserModel).toMatchSnapshot();
            });
        });
        describe("intersection", () => {
            test("simple", () => {
                const { statement: model, typeChecker } = (0, tsTestUtils_1.compileStatement)(`
          type MyModel = {a: string} & ({b: number} | {c?: boolean})
        `, typescript_1.default.SyntaxKind.TypeAliasDeclaration);
                const parserModel = (0, generateParserModel_1.default)(typeChecker, model, "data");
                expect(parserModel).toMatchSnapshot();
            });
        });
    });
    describe("for enums", () => {
        test("enum with string enum members", () => {
            const { statements: [model], typeChecker, } = (0, tsTestUtils_1.compileStatements)(`
          type MyModel = {
            en: MyEnum
          }
          enum MyEnum {
            A = "a",
            B = "b",
          }
        `);
            const parserModel = (0, generateParserModel_1.default)(typeChecker, model, "data");
            expect(parserModel).toMatchSnapshot();
        });
        test("enum with number enum members", () => {
            const { statements: [model], typeChecker, } = (0, tsTestUtils_1.compileStatements)(`
          type MyModel = {
            en: MyEnum
          }
          enum MyEnum {
            A = 0,
            B = 1,
          }
        `);
            const parserModel = (0, generateParserModel_1.default)(typeChecker, model, "data");
            expect(parserModel).toMatchSnapshot();
        });
        test("enum with auto number enum members", () => {
            const { statements: [model], typeChecker, } = (0, tsTestUtils_1.compileStatements)(`
          type MyModel = {
            en: MyEnum
          }
          enum MyEnum {
            A = 0,
            B = 100,
            C,
          }
        `);
            const parserModel = (0, generateParserModel_1.default)(typeChecker, model, "data");
            expect(parserModel).toMatchSnapshot();
        });
        test("enum member", () => {
            const { statements: [model], typeChecker, } = (0, tsTestUtils_1.compileStatements)(`
          type MyModel = {
            en: MyEnum.A
          }
          enum MyEnum {
            A,
            B,
            C,
          }
        `);
            const parserModel = (0, generateParserModel_1.default)(typeChecker, model, "data");
            expect(parserModel).toMatchSnapshot();
        });
        test("enum model", () => {
            const { statements: [model], typeChecker, } = (0, tsTestUtils_1.compileStatements)(`
          type MyModel = MyEnum
          enum MyEnum {
            A,
            B,
            C,
          }
        `);
            const parserModel = (0, generateParserModel_1.default)(typeChecker, model, "data");
            expect(parserModel).toMatchSnapshot();
        });
        test("enum member model", () => {
            const { statements: [model], typeChecker, } = (0, tsTestUtils_1.compileStatements)(`
          type MyModel = MyEnum.B
          enum MyEnum {
            A,
            B,
            C,
          }
        `);
            const parserModel = (0, generateParserModel_1.default)(typeChecker, model, "data");
            expect(parserModel).toMatchSnapshot();
        });
        test("enum root model", () => {
            const { statements: [enumModel], typeChecker, } = (0, tsTestUtils_1.compileStatements)(`
      export enum MyEnum {
        Aaa = "Aaa",
        Bbb = "Bbb",
        Ccc = "Ccc",
      }
      `);
            const parserModel = (0, generateParserModel_1.default)(typeChecker, enumModel, "data");
            expect(parserModel).toMatchSnapshot();
        });
    });
    describe("for generics", () => {
        test("type with generic parameter", () => {
            const { statement: model, typeChecker } = (0, tsTestUtils_1.compileStatement)(`
          type MyModel<T> = {
            prop: T
          }
        `, typescript_1.default.SyntaxKind.TypeAliasDeclaration);
            const parserModel = (0, generateParserModel_1.default)(typeChecker, model, "data");
            expect(parserModel).toMatchSnapshot();
        });
        test("type with default generic parameter", () => {
            const { statement: model, typeChecker } = (0, tsTestUtils_1.compileStatement)(`
          type MyModel<T = number> = {
            prop: T
          }
        `, typescript_1.default.SyntaxKind.TypeAliasDeclaration);
            const parserModel = (0, generateParserModel_1.default)(typeChecker, model, "data");
            expect(parserModel).toMatchSnapshot();
        });
        test("type with parameterized generic parameter", () => {
            const { statements: [model], typeChecker, } = (0, tsTestUtils_1.compileStatements)(`
          type MyModel = {
            a: Test<number>
          }
          interface Test<T> {
            b: T
            c: boolean
          }
        `);
            const parserModel = (0, generateParserModel_1.default)(typeChecker, model, "data");
            expect(parserModel).toMatchSnapshot();
        });
    });
    describe("reference", () => {
        test("to another interface", () => {
            const { statements: [model], typeChecker, } = (0, tsTestUtils_1.compileStatements)(`
          type MyModel = {
            a: Test
          }
          interface Test {
            b: number
            c: boolean
          }
        `);
            const parserModel = (0, generateParserModel_1.default)(typeChecker, model, "data");
            expect(parserModel).toMatchSnapshot();
        });
        test("insde a type literal", () => {
            const { statements: [model], typeChecker, } = (0, tsTestUtils_1.compileStatements)(`
          type MyModel = {
            a: {
              b: Test
            }
          }
          interface Test {
            b: number
            c: boolean
          }
        `);
            const parserModel = (0, generateParserModel_1.default)(typeChecker, model, "data");
            expect(parserModel).toMatchSnapshot();
        });
    });
    describe("other types", () => {
        test("any / unknown", () => {
            const { statement: model, typeChecker } = (0, tsTestUtils_1.compileStatement)(`
          type MyModel = {
            a: any
            b: unknown
          }
        `, typescript_1.default.SyntaxKind.TypeAliasDeclaration);
            const parserModel = (0, generateParserModel_1.default)(typeChecker, model, "data");
            expect(parserModel).toMatchSnapshot();
        });
        test("date", () => {
            const { statement: model, typeChecker } = (0, tsTestUtils_1.compileStatement)(`
          type MyModel = {
            a: Date
          }
        `, typescript_1.default.SyntaxKind.TypeAliasDeclaration);
            const parserModel = (0, generateParserModel_1.default)(typeChecker, model, "data");
            expect(parserModel).toMatchSnapshot();
        });
        test("Partial<Record<X, number>>", () => {
            const { statements: [model], typeChecker, } = (0, tsTestUtils_1.compileStatements)(`
        type Noot = Partial<Record<X, number>>;
        enum X {
          A,
          B,
          C,
        }
      `);
            const parserModel = (0, generateParserModel_1.default)(typeChecker, model, "data");
            expect(parserModel).toMatchSnapshot();
        });
        test("Partial<Record<X, string>>", () => {
            const { statements: [model], typeChecker, } = (0, tsTestUtils_1.compileStatements)(`
        type Noot = Partial<Record<X, string>>;
        enum X {
          A = "a",
          B = "b",
          C = "c",
        }
      `);
            const parserModel = (0, generateParserModel_1.default)(typeChecker, model, "data");
            expect(parserModel).toMatchSnapshot();
        });
        test("index type", () => {
            const { statement: model, typeChecker } = (0, tsTestUtils_1.compileStatement)(`
          type MyModel = {
            [name: string]: {
              kees: string
            }

            x: {
              kees: string
              kaas: {
                [xx: "aad" | "banaan"]: string
              }
            }
          }
        `, typescript_1.default.SyntaxKind.TypeAliasDeclaration);
            const parserModel = (0, generateParserModel_1.default)(typeChecker, model, "data");
            expect(parserModel).toMatchSnapshot();
        });
    });
    describe("mapped types", () => {
        test("simple", () => {
            const { statements: [model], typeChecker, } = (0, tsTestUtils_1.compileStatements)(`
          interface MyModel {
            x: {
              [key in "aap" | "noot"]: {
                y: string
              }
            }
          }
        `);
            const parserModel = (0, generateParserModel_1.default)(typeChecker, model, "data");
            expect(parserModel).toMatchSnapshot();
        });
        test.skip("mapping readonly keys to mutable keys", () => {
            // Example from https://www.typescriptlang.org/docs/handbook/2/mapped-types.html
            const { statements: [model], typeChecker, } = (0, tsTestUtils_1.compileStatements)(`
        type UnlockedAccount = CreateMutable<LockedAccount>;

        type CreateMutable<Type> = {
          readonly [Property in keyof Type]: Type[Property];
        };

        type LockedAccount = {
          readonly id: string;
          readonly name: string;
        };
        `);
            // TODO because the type CreateMutable has computed properties we can't
            // generate a parser for it. The result of `keyof` depends on the Type parameter.
            const parserModel = (0, generateParserModel_1.default)(typeChecker, model, "data");
            expect(parserModel).toMatchSnapshot();
        });
        test("mapping props to booleans", () => {
            // Example from https://www.typescriptlang.org/docs/handbook/2/mapped-types.html
            const { statements: [model], typeChecker, } = (0, tsTestUtils_1.compileStatements)(`
      type FeatureOptions = Partial<OptionsFlags<FeatureFlags>>;

      type FeatureFlags = {
        darkMode: () => void;
        newUserProfile: () => void;
      };

      type OptionsFlags<Type> = {
        [Property in keyof Type]: boolean;
      };
        `);
            const parserModel = (0, generateParserModel_1.default)(typeChecker, model, "data");
            expect(parserModel).toMatchSnapshot();
        });
    });
    describe("type operator node", () => {
        test("keyof an interface", () => {
            const { statements: [model], typeChecker, } = (0, tsTestUtils_1.compileStatements)(`
          interface MyModel {
            props: {
              [prop in keyof MyOtherModel]: number
            }
          }

          interface MyOtherModel {
            kaas: number
            koos: string
          }
        `);
            const parserModel = (0, generateParserModel_1.default)(typeChecker, model, "data");
            expect(parserModel).toMatchSnapshot();
        });
    });
});
