"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.hasErrorCode = exports.PortInUseError = exports.ParseError = exports.MissingPheroFileError = exports.MissingTSConfigFile = void 0;
const typescript_1 = __importDefault(require("typescript"));
class MissingTSConfigFile extends Error {
    constructor(projectDir) {
        super(`Could not find a valid tsconfig.json on path ${projectDir}/tsconfig.json`);
    }
}
exports.MissingTSConfigFile = MissingTSConfigFile;
class MissingPheroFileError extends Error {
    constructor(projectDir) {
        super(`Could not find the phero.ts file on path ${projectDir}`);
    }
}
exports.MissingPheroFileError = MissingPheroFileError;
class ParseError extends Error {
    constructor(message, node) {
        super(generateErrorMessage(message, node));
        this.node = node;
    }
}
exports.ParseError = ParseError;
function generateErrorMessage(message, node) {
    node.getSourceFile();
    return typescript_1.default.formatDiagnosticsWithColorAndContext([
        {
            code: "-PheroError",
            category: typescript_1.default.DiagnosticCategory.Error,
            file: node.getSourceFile(),
            messageText: `\n\n${message}`,
            start: node.pos,
            length: node.end - node.pos,
        },
    ], {
        getCanonicalFileName: (f) => f,
        getCurrentDirectory: () => "",
        getNewLine: () => "\n",
    });
}
class PortInUseError extends Error {
    constructor(port) {
        super(`Port ${port} is already in use`);
    }
}
exports.PortInUseError = PortInUseError;
function hasErrorCode(error) {
    return (typeof error === "object" &&
        error !== null &&
        typeof error.code === "string");
}
exports.hasErrorCode = hasErrorCode;
