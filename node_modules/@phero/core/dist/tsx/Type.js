"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Type = void 0;
const typescript_1 = __importDefault(require("typescript"));
const typeReference_1 = require("./typeReference");
class Type {
    static get any() {
        return typescript_1.default.factory.createKeywordTypeNode(typescript_1.default.SyntaxKind.AnyKeyword);
    }
    static get boolean() {
        return typescript_1.default.factory.createKeywordTypeNode(typescript_1.default.SyntaxKind.BooleanKeyword);
    }
    static get string() {
        return typescript_1.default.factory.createKeywordTypeNode(typescript_1.default.SyntaxKind.StringKeyword);
    }
    static get number() {
        return typescript_1.default.factory.createKeywordTypeNode(typescript_1.default.SyntaxKind.NumberKeyword);
    }
    static get undefined() {
        return typescript_1.default.factory.createKeywordTypeNode(typescript_1.default.SyntaxKind.UndefinedKeyword);
    }
    static get void() {
        return typescript_1.default.factory.createKeywordTypeNode(typescript_1.default.SyntaxKind.VoidKeyword);
    }
    static get never() {
        return typescript_1.default.factory.createKeywordTypeNode(typescript_1.default.SyntaxKind.NeverKeyword);
    }
    static array(elementType) {
        return typescript_1.default.factory.createArrayTypeNode(elementType);
    }
    static union(...types) {
        return typescript_1.default.factory.createUnionTypeNode(types);
    }
    static intersection(...types) {
        return typescript_1.default.factory.createIntersectionTypeNode(types);
    }
    static literalType(literal) {
        return typescript_1.default.factory.createLiteralTypeNode(literal);
    }
}
exports.Type = Type;
Type.reference = typeReference_1.typeReference;
