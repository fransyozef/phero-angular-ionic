"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Expression = void 0;
const typescript_1 = __importDefault(require("typescript"));
const binaryExpression_1 = require("./binaryExpression");
const arrowFunction_1 = require("./arrowFunction");
const prefixUnaryExpression_1 = require("./prefixUnaryExpression");
const postfixUnaryExpression_1 = require("./postfixUnaryExpression");
class Expression {
    static await(expression) {
        return typescript_1.default.factory.createAwaitExpression(expression);
    }
    static negate(expression) {
        return Expression.prefixUnary("!", expression);
    }
    static propertyAccess(obj, prop, ...deepProps) {
        function create(left, right) {
            return typescript_1.default.factory.createPropertyAccessExpression(left, right);
        }
        return deepProps.reduce(create, create(typeof obj === "string" ? typescript_1.default.factory.createIdentifier(obj) : obj, prop));
    }
    static elementAccess(arr, index) {
        return typescript_1.default.factory.createElementAccessChain(typeof arr === "string" ? typescript_1.default.factory.createIdentifier(arr) : arr, undefined, typeof index === "string" ? typescript_1.default.factory.createIdentifier(index) : index);
    }
    static call(name, opts) {
        var _a;
        return typescript_1.default.factory.createCallExpression(typeof name === "string" ? typescript_1.default.factory.createIdentifier(name) : name, opts === null || opts === void 0 ? void 0 : opts.typeArgs, (_a = opts === null || opts === void 0 ? void 0 : opts.args) === null || _a === void 0 ? void 0 : _a.map((arg) => typeof arg === "string" ? typescript_1.default.factory.createIdentifier(arg) : arg));
    }
    static identifier(text) {
        return typescript_1.default.factory.createIdentifier(text);
    }
    static ternary(condition, whenTrue, whenFalse) {
        return typescript_1.default.factory.createConditionalExpression(condition, typescript_1.default.factory.createToken(typescript_1.default.SyntaxKind.QuestionToken), whenTrue, typescript_1.default.factory.createToken(typescript_1.default.SyntaxKind.ColonToken), whenFalse);
    }
    static typeof(expression) {
        return typescript_1.default.factory.createTypeOfExpression(expression);
    }
    static parenthesis(expression) {
        return typescript_1.default.factory.createParenthesizedExpression(expression);
    }
    static new(expression, props) {
        return typescript_1.default.factory.createNewExpression(typeof expression === "string"
            ? typescript_1.default.factory.createIdentifier(expression)
            : expression, props.typeArgs, props.args);
    }
}
exports.Expression = Expression;
Expression.binary = binaryExpression_1.binaryExpression;
Expression.prefixUnary = prefixUnaryExpression_1.prefixUnaryExpression;
Expression.postfixUnary = postfixUnaryExpression_1.postfixUnaryExpression;
Expression.arrowFunction = arrowFunction_1.arrowFunction;
