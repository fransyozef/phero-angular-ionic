import ts from "typescript";
import { binaryExpression } from "./binaryExpression";
import { arrowFunction } from "./arrowFunction";
import { prefixUnaryExpression } from "./prefixUnaryExpression";
import { postfixUnaryExpression } from "./postfixUnaryExpression";
export declare class Expression {
    static await(expression: ts.Expression): ts.AwaitExpression;
    static binary: typeof binaryExpression;
    static prefixUnary: typeof prefixUnaryExpression;
    static postfixUnary: typeof postfixUnaryExpression;
    static negate(expression: ts.Expression): ts.PrefixUnaryExpression;
    static propertyAccess(obj: string | ts.Expression, prop: string, ...deepProps: string[]): ts.PropertyAccessExpression;
    static elementAccess(arr: string | ts.Expression, index: string | number | ts.Expression): ts.ElementAccessExpression;
    static call(name: string | ts.Expression, opts?: {
        args?: (string | ts.Expression)[];
        typeArgs?: ts.TypeNode[];
    }): ts.CallExpression;
    static arrowFunction: typeof arrowFunction;
    static identifier(text: string): ts.Identifier;
    static ternary(condition: ts.Expression, whenTrue: ts.Expression, whenFalse: ts.Expression): ts.ConditionalExpression;
    static typeof(expression: ts.Expression): ts.TypeOfExpression;
    static parenthesis(expression: ts.Expression): ts.ParenthesizedExpression;
    static new(expression: string | ts.Expression, props: {
        typeArgs?: ts.TypeNode[];
        args?: ts.Expression[];
    }): ts.NewExpression;
}
