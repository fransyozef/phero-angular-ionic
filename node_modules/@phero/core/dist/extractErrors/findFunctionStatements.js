"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const typescript_1 = __importDefault(require("typescript"));
function findFunctionStatements(func) {
    if (!func.body) {
        return [];
    }
    if (!typescript_1.default.isBlock(func.body)) {
        // an arrow function with an Expression as body, e.g.: () => 1 + 2
        return [typescript_1.default.factory.createExpressionStatement(func.body)];
    }
    return func.body.statements.flatMap((st) => findInnerStatements(st, []));
}
exports.default = findFunctionStatements;
function findInnerStatements(statement, accum) {
    var _a, _b, _c, _d;
    const newAccum = [...accum, statement];
    if (typescript_1.default.isBlock(statement)) {
        return statement.statements.reduce((result, st) => findInnerStatements(st, result), newAccum);
    }
    if (typescript_1.default.isIfStatement(statement)) {
        const statements = statement.elseStatement
            ? [statement.thenStatement, statement.elseStatement]
            : [statement.thenStatement];
        return statements.reduce((result, st) => findInnerStatements(st, result), newAccum);
    }
    if (typescript_1.default.isIterationStatement(statement, true)) {
        return findInnerStatements(statement.statement, newAccum);
    }
    if (typescript_1.default.isWithStatement(statement)) {
        return findInnerStatements(statement.statement, newAccum);
    }
    if (typescript_1.default.isSwitchStatement(statement)) {
        const statements = statement.caseBlock.clauses.flatMap((clause) => clause.statements);
        return statements.reduce((result, st) => findInnerStatements(st, result), newAccum);
    }
    if (typescript_1.default.isLabeledStatement(statement)) {
        return findInnerStatements(statement.statement, newAccum);
    }
    if (typescript_1.default.isTryStatement(statement)) {
        const statements = [
            ...statement.tryBlock.statements,
            ...((_b = (_a = statement.catchClause) === null || _a === void 0 ? void 0 : _a.block.statements) !== null && _b !== void 0 ? _b : []),
            ...((_d = (_c = statement.finallyBlock) === null || _c === void 0 ? void 0 : _c.statements) !== null && _d !== void 0 ? _d : []),
        ];
        return statements.reduce((result, st) => findInnerStatements(st, result), newAccum);
    }
    return newAccum;
}
