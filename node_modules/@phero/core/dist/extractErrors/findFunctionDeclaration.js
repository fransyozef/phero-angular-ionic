"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const typescript_1 = __importDefault(require("typescript"));
const tsUtils_1 = require("../tsUtils");
function findFunctionDeclaration(callExpression, typeChecker) {
    return unpackExpression(callExpression, typeChecker);
}
exports.default = findFunctionDeclaration;
function unpackExpression(expression, typeChecker) {
    var _a, _b;
    if (typescript_1.default.isIdentifier(expression)) {
        const declaration = getDeclarationForExpression(expression, typeChecker);
        if (!declaration) {
            return [];
        }
        return unpackDeclaration(declaration, expression, typeChecker);
    }
    if (typescript_1.default.isCallExpression(expression)) {
        return [
            ...unpackExpression(expression.expression, typeChecker),
            ...expression.arguments.flatMap((arg) => unpackExpression(arg, typeChecker)),
        ];
    }
    if (typescript_1.default.isNewExpression(expression)) {
        return [
            ...unpackExpression(expression.expression, typeChecker),
            ...((_b = (_a = expression.arguments) === null || _a === void 0 ? void 0 : _a.flatMap((arg) => unpackExpression(arg, typeChecker))) !== null && _b !== void 0 ? _b : []),
        ];
    }
    if (typescript_1.default.isYieldExpression(expression)) {
        return expression.expression
            ? unpackExpression(expression.expression, typeChecker)
            : [];
    }
    if (typescript_1.default.isBinaryExpression(expression)) {
        return [expression.left, expression.right].flatMap((sub) => unpackExpression(sub, typeChecker));
    }
    if (typescript_1.default.isConditionalExpression(expression)) {
        return [
            expression.condition,
            expression.whenTrue,
            expression.whenFalse,
        ].flatMap((sub) => unpackExpression(sub, typeChecker));
    }
    if (typescript_1.default.isAsExpression(expression)) {
        return unpackExpression(expression.expression, typeChecker);
    }
    if (typescript_1.default.isPrefixUnaryExpression(expression)) {
        return unpackExpression(expression.operand, typeChecker);
    }
    if (typescript_1.default.isPostfixUnaryExpression(expression)) {
        return unpackExpression(expression.operand, typeChecker);
    }
    if (typescript_1.default.isDeleteExpression(expression)) {
        return unpackExpression(expression.expression, typeChecker);
    }
    if (typescript_1.default.isTypeOfExpression(expression)) {
        return unpackExpression(expression.expression, typeChecker);
    }
    if (typescript_1.default.isVoidExpression(expression)) {
        return unpackExpression(expression.expression, typeChecker);
    }
    if (typescript_1.default.isAwaitExpression(expression)) {
        return unpackExpression(expression.expression, typeChecker);
    }
    if (typescript_1.default.isTemplateExpression(expression)) {
        return expression.templateSpans.flatMap((s) => unpackExpression(s.expression, typeChecker));
    }
    if (typescript_1.default.isParenthesizedExpression(expression)) {
        return unpackExpression(expression.expression, typeChecker);
    }
    if (typescript_1.default.isPropertyAccessExpression(expression)) {
        return [
            ...unpackExpression(expression.expression, typeChecker),
            ...unpackExpression(expression.name, typeChecker),
        ];
    }
    if (typescript_1.default.isElementAccessExpression(expression)) {
        return unpackExpression(expression.expression, typeChecker);
    }
    if (typescript_1.default.isArrayLiteralExpression(expression)) {
        return expression.elements.flatMap((el) => unpackExpression(el, typeChecker));
    }
    if (typescript_1.default.isSpreadElement(expression)) {
        return unpackExpression(expression.expression, typeChecker);
    }
    if (typescript_1.default.isObjectLiteralExpression(expression)) {
        return expression.properties.flatMap((prop) => {
            if (typescript_1.default.isPropertyAssignment(prop)) {
                return unpackExpression(prop.initializer, typeChecker);
            }
            if (typescript_1.default.isShorthandPropertyAssignment(prop)) {
                // TODO follow prop.name, it could reference a variable with a call node as initializer
                return prop.objectAssignmentInitializer
                    ? unpackExpression(prop.objectAssignmentInitializer, typeChecker)
                    : [];
            }
            if (typescript_1.default.isSpreadAssignment(prop)) {
                // TODO follow prop.name, it could reference a variable with a call node as initializer
                return unpackExpression(prop.expression, typeChecker);
            }
            return [];
        });
    }
    if (typescript_1.default.isTypeAssertionExpression(expression)) {
        return unpackExpression(expression.expression, typeChecker);
    }
    if (typescript_1.default.isNonNullExpression(expression)) {
        return unpackExpression(expression.expression, typeChecker);
    }
    if (typescript_1.default.isToken(expression) &&
        expression.kind === typescript_1.default.SyntaxKind.SuperKeyword) {
        const declaration = getDeclarationForExpression(expression, typeChecker);
        if (!declaration) {
            return [];
        }
        return unpackDeclaration(declaration, expression, typeChecker);
    }
    if (typescript_1.default.isArrowFunction(expression) || typescript_1.default.isFunctionExpression(expression)) {
        return [expression];
    }
    return [];
}
function unpackDeclaration(declaration, expression, typeChecker) {
    var _a, _b;
    if (typescript_1.default.isVariableDeclaration(declaration)) {
        if (!declaration.initializer) {
            return [];
        }
        return unpackExpression(declaration.initializer, typeChecker);
    }
    if (typescript_1.default.isSetAccessorDeclaration(declaration)) {
        return [];
    }
    // Not sure about this one...
    // occurs with `console.log`
    if (typescript_1.default.isMethodSignature(declaration)) {
        return [];
    }
    if (typescript_1.default.isClassDeclaration(declaration)) {
        const constructor = declaration.members.find((m) => typescript_1.default.isConstructorDeclaration(m));
        const extendedClass = (_b = (_a = declaration.heritageClauses) === null || _a === void 0 ? void 0 : _a.find((clause) => clause.token === typescript_1.default.SyntaxKind.ExtendsKeyword)) === null || _b === void 0 ? void 0 : _b.types[0];
        return [
            ...(constructor && typescript_1.default.isConstructorDeclaration(constructor)
                ? [constructor]
                : []),
            ...(extendedClass && typescript_1.default.isClassDeclaration(extendedClass)
                ? unpackDeclaration(extendedClass, expression, typeChecker)
                : []),
        ];
    }
    if (typescript_1.default.isParameter(declaration)) {
        return [];
    }
    if ((0, tsUtils_1.isExternalDeclaration)(declaration)) {
        return [];
    }
    if (typescript_1.default.isImportDeclaration(declaration) ||
        typescript_1.default.isImportClause(declaration) ||
        typescript_1.default.isImportSpecifier(declaration)) {
        const symbol = typeChecker.getSymbolAtLocation(expression);
        if (!symbol) {
            return [];
        }
        const aliasSymbol = typeChecker.getAliasedSymbol(symbol);
        if (!aliasSymbol.valueDeclaration) {
            return [];
        }
        return unpackDeclaration(aliasSymbol.valueDeclaration, expression, typeChecker);
    }
    if (typescript_1.default.isArrowFunction(declaration) ||
        typescript_1.default.isFunctionDeclaration(declaration) ||
        typescript_1.default.isMethodDeclaration(declaration) ||
        typescript_1.default.isConstructorDeclaration(declaration) ||
        typescript_1.default.isGetAccessorDeclaration(declaration)) {
        return [declaration];
    }
    return [];
}
function getDeclarationForExpression(expression, typeChecker) {
    var _a, _b;
    const symbol = typeChecker.getSymbolAtLocation(expression);
    const declaration = (_a = symbol === null || symbol === void 0 ? void 0 : symbol.valueDeclaration) !== null && _a !== void 0 ? _a : (_b = symbol === null || symbol === void 0 ? void 0 : symbol.declarations) === null || _b === void 0 ? void 0 : _b[0];
    return declaration;
}
