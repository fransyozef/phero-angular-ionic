"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.findCallExpressionsInExpression = exports.findCallExpressionsInStatement = void 0;
const typescript_1 = __importDefault(require("typescript"));
function findCallExpressionsInStatement(statement) {
    var _a, _b;
    if (typescript_1.default.isExpressionStatement(statement) ||
        typescript_1.default.isIfStatement(statement) ||
        typescript_1.default.isDoStatement(statement) ||
        typescript_1.default.isWhileStatement(statement) ||
        typescript_1.default.isReturnStatement(statement) ||
        typescript_1.default.isWithStatement(statement)) {
        return findCallExpressionsInExpression(statement.expression);
    }
    if (typescript_1.default.isVariableStatement(statement)) {
        return statement.declarationList.declarations
            .map((d) => d.initializer)
            .flatMap(findCallExpressionsInExpression);
    }
    if (typescript_1.default.isForStatement(statement)) {
        return [
            ...(statement.initializer &&
                typescript_1.default.isVariableDeclarationList(statement.initializer)
                ? statement.initializer.declarations.map((d) => d.initializer)
                : [statement.initializer]),
            statement.condition,
            statement.incrementor,
        ].flatMap(findCallExpressionsInExpression);
    }
    if (typescript_1.default.isForInStatement(statement) || typescript_1.default.isForOfStatement(statement)) {
        return [
            ...(statement.initializer &&
                typescript_1.default.isVariableDeclarationList(statement.initializer)
                ? statement.initializer.declarations.map((d) => d.initializer)
                : [statement.initializer]),
            statement.expression,
        ].flatMap(findCallExpressionsInExpression);
    }
    if (typescript_1.default.isSwitchStatement(statement)) {
        return statement.caseBlock.clauses
            .reduce((result, clause) => {
            return typescript_1.default.isCaseClause(clause)
                ? [...result, clause.expression]
                : result;
        }, [statement.expression])
            .flatMap(findCallExpressionsInExpression);
    }
    if (typescript_1.default.isTryStatement(statement)) {
        return findCallExpressionsInExpression((_b = (_a = statement.catchClause) === null || _a === void 0 ? void 0 : _a.variableDeclaration) === null || _b === void 0 ? void 0 : _b.initializer);
    }
    return [];
}
exports.findCallExpressionsInStatement = findCallExpressionsInStatement;
// TODO support for JSX expressions
function findCallExpressionsInExpression(expr) {
    var _a, _b;
    if (!expr) {
        return [];
    }
    // TODO ? ts.TaggedTemplateExpression
    if (typescript_1.default.isCallExpression(expr)) {
        return [...expr.arguments.flatMap(findCallExpressionsInExpression), expr];
    }
    if (typescript_1.default.isNewExpression(expr)) {
        return [
            ...((_b = (_a = expr.arguments) === null || _a === void 0 ? void 0 : _a.flatMap(findCallExpressionsInExpression)) !== null && _b !== void 0 ? _b : []),
            expr,
        ];
    }
    if (typescript_1.default.isYieldExpression(expr)) {
        return findCallExpressionsInExpression(expr.expression);
    }
    if (typescript_1.default.isBinaryExpression(expr)) {
        return [expr.left, expr.right].flatMap(findCallExpressionsInExpression);
    }
    if (typescript_1.default.isConditionalExpression(expr)) {
        return [expr.condition, expr.whenTrue, expr.whenFalse].flatMap(findCallExpressionsInExpression);
    }
    if (typescript_1.default.isAsExpression(expr)) {
        return findCallExpressionsInExpression(expr.expression);
    }
    if (typescript_1.default.isPrefixUnaryExpression(expr)) {
        return findCallExpressionsInExpression(expr.operand);
    }
    if (typescript_1.default.isPostfixUnaryExpression(expr)) {
        return findCallExpressionsInExpression(expr.operand);
    }
    if (typescript_1.default.isDeleteExpression(expr)) {
        return findCallExpressionsInExpression(expr.expression);
    }
    if (typescript_1.default.isTypeOfExpression(expr)) {
        return findCallExpressionsInExpression(expr.expression);
    }
    if (typescript_1.default.isVoidExpression(expr)) {
        return findCallExpressionsInExpression(expr.expression);
    }
    if (typescript_1.default.isAwaitExpression(expr)) {
        return findCallExpressionsInExpression(expr.expression);
    }
    if (typescript_1.default.isTemplateExpression(expr)) {
        return expr.templateSpans.flatMap((s) => findCallExpressionsInExpression(s.expression));
    }
    if (typescript_1.default.isParenthesizedExpression(expr)) {
        return findCallExpressionsInExpression(expr.expression);
    }
    if (typescript_1.default.isPropertyAccessExpression(expr)) {
        return findCallExpressionsInExpression(expr.expression);
    }
    if (typescript_1.default.isElementAccessExpression(expr)) {
        return findCallExpressionsInExpression(expr.expression);
    }
    if (typescript_1.default.isArrayLiteralExpression(expr)) {
        return expr.elements.flatMap(findCallExpressionsInExpression);
    }
    if (typescript_1.default.isSpreadElement(expr)) {
        return findCallExpressionsInExpression(expr.expression);
    }
    if (typescript_1.default.isObjectLiteralExpression(expr)) {
        return expr.properties.flatMap((prop) => {
            if (typescript_1.default.isPropertyAssignment(prop)) {
                return findCallExpressionsInExpression(prop.initializer);
            }
            if (typescript_1.default.isShorthandPropertyAssignment(prop)) {
                // TODO follow prop.name, it could reference a variable with a call expr as initializer
                return findCallExpressionsInExpression(prop.objectAssignmentInitializer);
            }
            if (typescript_1.default.isSpreadAssignment(prop)) {
                // TODO follow prop.name, it could reference a variable with a call expr as initializer
                return findCallExpressionsInExpression(prop.expression);
            }
            return [];
        });
    }
    if (typescript_1.default.isTypeAssertionExpression(expr)) {
        return findCallExpressionsInExpression(expr.expression);
    }
    if (typescript_1.default.isNonNullExpression(expr)) {
        return findCallExpressionsInExpression(expr.expression);
    }
    return [];
}
exports.findCallExpressionsInExpression = findCallExpressionsInExpression;
