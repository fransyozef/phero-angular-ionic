"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const typescript_1 = __importDefault(require("typescript"));
const tsx = __importStar(require("../tsx"));
const tsUtils_1 = require("../tsUtils");
function parseThrowStatement(throwStatement, typeChecker) {
    if (!typescript_1.default.isNewExpression(throwStatement.expression)) {
        // TODO Maybe emit a warning here?
        return undefined;
    }
    const classDeclaration = getClassDeclaration(throwStatement.expression, typeChecker);
    if (classDeclaration === undefined) {
        // class has no Error super type
        return undefined;
    }
    const superClasses = getSuperClasses(classDeclaration, [], typeChecker);
    if (superClasses === undefined) {
        // class has no Error super type
        return undefined;
    }
    const properties = [
        { name: "message", type: tsx.type.string },
        ...[classDeclaration, ...superClasses].flatMap((classDeclaration) => findPublicProperties(classDeclaration, typeChecker)),
    ];
    if (!classDeclaration.name) {
        return undefined;
    }
    return {
        name: classDeclaration.name.text,
        sourceFile: classDeclaration.getSourceFile().fileName,
        properties,
        ref: classDeclaration,
    };
}
exports.default = parseThrowStatement;
function getSuperClasses(classDeclaration, accum, typeChecker) {
    var _a, _b, _c;
    const extendsType = (_b = (_a = classDeclaration.heritageClauses) === null || _a === void 0 ? void 0 : _a.find((clause) => clause.token === typescript_1.default.SyntaxKind.ExtendsKeyword)) === null || _b === void 0 ? void 0 : _b.types[0];
    if (!extendsType) {
        // class has no Error super type
        // TODO Maybe emit a warning here?
        return;
    }
    const typeNode = typeChecker.getTypeFromTypeNode(extendsType);
    const refSymbol = (_c = typeNode.aliasSymbol) !== null && _c !== void 0 ? _c : typeNode.symbol;
    if (refSymbol.name === "Error") {
        return accum;
    }
    const superClass = getClassDeclaration(extendsType, typeChecker);
    if (superClass === undefined) {
        return undefined;
    }
    return getSuperClasses(superClass, [...accum, superClass], typeChecker);
}
function getClassDeclaration(node, typeChecker) {
    var _a;
    const type = typeChecker.getTypeAtLocation(node);
    const symbol = (_a = type.aliasSymbol) !== null && _a !== void 0 ? _a : type.symbol;
    const classDeclaration = symbol.valueDeclaration;
    if (!classDeclaration || !typescript_1.default.isClassDeclaration(classDeclaration)) {
        return undefined;
    }
    return classDeclaration;
}
function findPublicProperties(classDeclaration, typeChecker) {
    const result = [];
    for (const member of classDeclaration.members) {
        if ((typescript_1.default.isPropertyDeclaration(member) ||
            typescript_1.default.isGetAccessorDeclaration(member)) &&
            (member.modifiers === undefined ||
                (0, tsUtils_1.hasModifier)(member, typescript_1.default.SyntaxKind.PublicKeyword))) {
            const typeNode = typeChecker.typeToTypeNode(typeChecker.getTypeAtLocation(member), member, undefined);
            if (typeNode) {
                result.push({
                    name: (0, tsUtils_1.getNameAsString)(member.name),
                    type: typeNode,
                });
            }
        }
        if (typescript_1.default.isConstructorDeclaration(member)) {
            for (const param of member.parameters) {
                if ((0, tsUtils_1.hasModifier)(param, typescript_1.default.SyntaxKind.PublicKeyword) &&
                    !typescript_1.default.isObjectBindingPattern(param.name) &&
                    !typescript_1.default.isArrayBindingPattern(param.name)) {
                    const typeNode = typeChecker.typeToTypeNode(typeChecker.getTypeAtLocation(param), param, undefined);
                    if (typeNode) {
                        result.push({
                            name: param.name.text,
                            type: typeNode,
                        });
                    }
                }
            }
        }
    }
    return result;
}
