"use strict";
// import { compile } from "./testCompiler"
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const typescript_1 = __importDefault(require("typescript"));
const parsePheroApp_1 = require("./parsePheroApp");
const tsTestUtils_1 = require("../tsTestUtils");
function parseProgram(prog) {
    // if (prog.getSemanticDiagnostics().length) {
    //   console.log("OEPS COMPILE ERRORS DETECTED")
    // }
    const pheroFile = prog.getSourceFile("phero.ts");
    if (!pheroFile) {
        throw new Error("No phero file");
    }
    return (0, parsePheroApp_1.parsePheroApp)(pheroFile, prog.getTypeChecker());
}
function expectFunctionDeclarationWithName(func, name) {
    var _a;
    expect((_a = func === null || func === void 0 ? void 0 : func.name) === null || _a === void 0 ? void 0 : _a.getText()).toBe(name);
    expect(func === null || func === void 0 ? void 0 : func.kind).toBe(typescript_1.default.SyntaxKind.FunctionDeclaration);
}
describe("parsePheroApp middleware", () => {
    test("should parse middleware", () => {
        const parsedApp = parseProgram((0, tsTestUtils_1.createTestProgram)(`
        type PheroNextFunction<T = void> = T extends void
          ? () => Promise<void>
          : (ctx: T) => Promise<void>

        type PheroContext<T = {}> = T
        type PheroParams<T = {}> = Partial<T>

        async function getArticle(ctx: PheroContext<{ x: number }>, aap: string): Promise<string> {
          return "ok"
        }

        async function myMiddleware(params: PheroParams, context: PheroContext, next: PheroNextFunction<{ x: number }) {
          await next({ x: 123 })
        }

        export const articleService = createService({
          getArticle,
        }, {
          middleware: [myMiddleware]
        })
      `));
        expect(parsedApp).toMatchObject({
            services: [
                expect.objectContaining({
                    name: "articleService",
                    funcs: [
                        expect.objectContaining({
                            name: "getArticle",
                        }),
                    ],
                }),
            ],
        });
        expectFunctionDeclarationWithName(parsedApp.services[0].funcs[0].actualFunction, "getArticle");
    });
});
