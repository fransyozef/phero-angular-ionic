"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const typescript_1 = __importDefault(require("typescript"));
const tsUtils_1 = require("../tsUtils");
const IGNORE_SYNTAX_KIND = [
    typescript_1.default.SyntaxKind.StringKeyword,
    typescript_1.default.SyntaxKind.BooleanKeyword,
    typescript_1.default.SyntaxKind.NumberKeyword,
    typescript_1.default.SyntaxKind.LiteralType,
    typescript_1.default.SyntaxKind.ImportSpecifier,
    typescript_1.default.SyntaxKind.VoidKeyword,
    typescript_1.default.SyntaxKind.AnyKeyword,
    typescript_1.default.SyntaxKind.UndefinedKeyword,
];
function parseModels(funcs, typeChecker) {
    const models = [];
    const addedSymbols = [];
    for (const param of funcs.flatMap((func) => func.parameters)) {
        doType(param.type);
    }
    for (const returnType of funcs.flatMap((func) => func.returnType)) {
        doType(returnType);
    }
    function doType(typeNode) {
        var _a, _b, _c, _d;
        if (!typeNode) {
            return;
        }
        if (typescript_1.default.isTypeReferenceNode(typeNode)) {
            for (const typeArgument of (_a = typeNode.typeArguments) !== null && _a !== void 0 ? _a : []) {
                doType(typeArgument);
            }
            // this is the best way to get the actual declaration of a TypeReferenceNode
            // this works for interfaces and type aliases
            const symbol = typeChecker.getSymbolAtLocation(typeNode.typeName);
            if (!symbol || (0, tsUtils_1.isExternalSymbol)(symbol)) {
                return;
            }
            addedSymbols.push(symbol);
            for (const declaration of (_b = symbol.declarations) !== null && _b !== void 0 ? _b : []) {
                doDeclaration(declaration);
            }
            if ((symbol.flags & typescript_1.default.SymbolFlags.Alias) === typescript_1.default.SymbolFlags.Alias) {
                const aliasSymbol = typeChecker.getAliasedSymbol(symbol);
                if (aliasSymbol && !addedSymbols.includes(aliasSymbol)) {
                    addedSymbols.push(aliasSymbol);
                    for (const d of (_c = aliasSymbol.declarations) !== null && _c !== void 0 ? _c : []) {
                        doDeclaration(d);
                    }
                }
            }
        }
        else if (typescript_1.default.isTypeLiteralNode(typeNode)) {
            doMembers(typeNode.members);
        }
        else if (typescript_1.default.isUnionTypeNode(typeNode)) {
            for (const unionElementType of typeNode.types) {
                doType(unionElementType);
            }
        }
        else if (typescript_1.default.isIntersectionTypeNode(typeNode)) {
            for (const intersectionElementType of typeNode.types) {
                doType(intersectionElementType);
            }
        }
        else if (typescript_1.default.isArrayTypeNode(typeNode)) {
            doType(typeNode.elementType);
        }
        else if (typescript_1.default.isExpressionWithTypeArguments(typeNode)) {
            const extendedType = typeChecker.getTypeFromTypeNode(typeNode);
            for (const declr of (_d = extendedType.symbol.declarations) !== null && _d !== void 0 ? _d : []) {
                doDeclaration(declr);
            }
        }
        else if (typescript_1.default.isIndexedAccessTypeNode(typeNode)) {
            doType(typeNode.objectType);
            doType(typeNode.indexType);
        }
        else if (typescript_1.default.isTupleTypeNode(typeNode)) {
            for (const el of typeNode.elements) {
                doType(el);
            }
        }
        else if (typescript_1.default.isParenthesizedTypeNode(typeNode)) {
            doType(typeNode.type);
        }
        else if (!IGNORE_SYNTAX_KIND.includes(typeNode.kind)) {
            console.warn("Model extracting not possible for node " + typeNode.kind);
        }
    }
    function doDeclaration(declaration) {
        var _a, _b, _c;
        if (!declaration) {
            return;
        }
        if ((0, tsUtils_1.isExternalDeclaration)(declaration)) {
            return;
        }
        if (typescript_1.default.isInterfaceDeclaration(declaration)) {
            doMembers(declaration.members);
            for (const heritageClause of (_a = declaration.heritageClauses) !== null && _a !== void 0 ? _a : []) {
                for (const type of heritageClause.types) {
                    doType(type);
                }
            }
            for (const typeParam of (_b = declaration.typeParameters) !== null && _b !== void 0 ? _b : []) {
                doDeclaration(typeParam);
            }
            models.push(declaration);
        }
        else if (typescript_1.default.isTypeAliasDeclaration(declaration)) {
            doType(declaration.type);
            for (const typeParam of (_c = declaration.typeParameters) !== null && _c !== void 0 ? _c : []) {
                doDeclaration(typeParam);
            }
            models.push(declaration);
        }
        else if (typescript_1.default.isEnumDeclaration(declaration)) {
            models.push(declaration);
        }
        else if (typescript_1.default.isEnumMember(declaration)) {
            doDeclaration(declaration.parent);
        }
        else if (typescript_1.default.isTypeParameterDeclaration(declaration)) {
            doType(declaration.constraint);
            doType(declaration.default);
        }
        else if (typescript_1.default.isTypeLiteralNode(declaration)) {
            doMembers(declaration.members);
        }
        else if (!IGNORE_SYNTAX_KIND.includes(declaration.kind)) {
            console.warn("Model extracting not possible for declaration " + declaration.kind);
        }
    }
    function doMembers(members) {
        for (const member of members) {
            if (typescript_1.default.isPropertySignature(member)) {
                doType(member.type);
            }
            else if (typescript_1.default.isIndexSignatureDeclaration(member)) {
                // TODO name, but could be computed property
                doType(member.type);
            }
        }
    }
    return models;
}
exports.default = parseModels;
