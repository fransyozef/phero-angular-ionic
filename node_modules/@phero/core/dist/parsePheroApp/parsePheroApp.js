"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.parsePheroApp = void 0;
const typescript_1 = __importDefault(require("typescript"));
const errors_1 = require("../errors");
const tsUtils_1 = require("../tsUtils");
const parseServiceDefinition_1 = __importDefault(require("./parseServiceDefinition"));
function parsePheroApp(pheroSourceFile, typeChecker) {
    var _a;
    const exportStatements = pheroSourceFile.statements.filter((s) => (0, tsUtils_1.hasModifier)(s, typescript_1.default.SyntaxKind.ExportKeyword) || typescript_1.default.isExportDeclaration(s));
    const services = [];
    for (const statement of exportStatements) {
        if (typescript_1.default.isVariableStatement(statement)) {
            for (const varDeclr of statement.declarationList.declarations) {
                const service = (0, parseServiceDefinition_1.default)(varDeclr, typeChecker);
                services.push(service);
            }
        }
        else if (typescript_1.default.isExportDeclaration(statement)) {
            if (!statement.exportClause) {
                throw new errors_1.ParseError(`S123: "export * from './file'" are not supported`, statement);
            }
            else if (!typescript_1.default.isNamedExports(statement.exportClause)) {
                throw new errors_1.ParseError("S124: Unsupported export statement", statement);
            }
            for (const specifier of statement.exportClause.elements) {
                const service = (0, parseServiceDefinition_1.default)(specifier, typeChecker);
                services.push(service);
            }
        }
        else {
            throw new errors_1.ParseError("S125: Unsupported export statement", statement);
        }
    }
    const modelMap = new Map();
    const errorMap = new Map();
    for (const service of services) {
        for (const model of service.models) {
            const modelName = model.name.text;
            if (modelName === "PheroContext") {
                continue;
            }
            if (!modelMap.has(modelName)) {
                modelMap.set(modelName, model);
            }
            else if (modelMap.get(modelName) !== model) {
                throw new errors_1.ParseError("You already have a different model with the same name, currently this is not possible. We intent to implement namespaces soon, stay tuned.", model);
            }
        }
        for (const parsedError of service.errors) {
            const errorName = parsedError.name;
            if (!errorMap.has(errorName)) {
                errorMap.set(errorName, parsedError);
            }
            else if (((_a = errorMap.get(errorName)) === null || _a === void 0 ? void 0 : _a.ref) !== parsedError.ref) {
                throw new errors_1.ParseError("You already have a different error class with the same name, currently this is not possible. We intent to implement namespaces soon, stay tuned.", parsedError.ref);
            }
        }
    }
    return {
        models: [...modelMap.values()],
        errors: [...errorMap.values()],
        services,
    };
}
exports.parsePheroApp = parsePheroApp;
