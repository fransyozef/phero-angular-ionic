"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const typescript_1 = __importDefault(require("typescript"));
const errors_1 = require("../errors");
const parseReturnType_1 = __importDefault(require("./parseReturnType"));
const tsUtils_1 = require("../tsUtils");
function parseFunctionDefinition(node, typeChecker) {
    if (typescript_1.default.isSpreadAssignment(node)) {
        throw new errors_1.ParseError("S116: Sorry, no support for spread assignment (yet)", node);
    }
    const parsedPheroFunctionDef = {
        name: parseFunctionName(node.name),
        ...parseActualFunction(node, typeChecker),
    };
    return parsedPheroFunctionDef;
}
exports.default = parseFunctionDefinition;
function parseFunctionName(functionName) {
    if (typescript_1.default.isNumericLiteral(functionName) ||
        typescript_1.default.isComputedPropertyName(functionName) ||
        typescript_1.default.isPrivateIdentifier(functionName) ||
        typescript_1.default.isObjectBindingPattern(functionName) ||
        typescript_1.default.isArrayBindingPattern(functionName)) {
        throw new errors_1.ParseError("S117: Function name should have a clear identifier, no support for computed names or binding patterns" +
            functionName.kind, functionName);
    }
    return functionName.text;
}
function parseActualFunction(node, typeChecker) {
    var _a, _b, _c, _d;
    if (typescript_1.default.isShorthandPropertyAssignment(node)) {
        const symbol = typeChecker.getShorthandAssignmentValueSymbol(node);
        if (!symbol || !((_a = symbol.declarations) === null || _a === void 0 ? void 0 : _a[0])) {
            throw new errors_1.ParseError(`S118: Can't find function (${node.kind})`, node);
        }
        return parseActualFunction((_b = symbol.declarations) === null || _b === void 0 ? void 0 : _b[0], typeChecker);
    }
    if (typescript_1.default.isImportSpecifier(node)) {
        return parseActualFunction(node.name, typeChecker);
    }
    if (typescript_1.default.isPropertyAssignment(node)) {
        return parseActualFunction(node.initializer, typeChecker);
    }
    if (typescript_1.default.isFunctionExpression(node) || typescript_1.default.isArrowFunction(node)) {
        return {
            actualFunction: node,
            parameters: node.parameters.map((p) => p),
            returnType: (0, parseReturnType_1.default)(node),
        };
    }
    if (typescript_1.default.isFunctionDeclaration(node)) {
        return {
            actualFunction: node,
            parameters: node.parameters.map((p) => p),
            returnType: (0, parseReturnType_1.default)(node),
        };
    }
    if (typescript_1.default.isVariableDeclaration(node) && node.initializer) {
        if (typescript_1.default.isArrowFunction(node.initializer)) {
            return {
                actualFunction: node.initializer,
                parameters: node.initializer.parameters.map((p) => p),
                returnType: (0, parseReturnType_1.default)(node.initializer),
            };
        }
        return parseActualFunction(node.initializer, typeChecker);
    }
    if (typescript_1.default.isIdentifier(node)) {
        const symbol = (0, tsUtils_1.resolveSymbol)(node, typeChecker);
        if (!((_c = symbol === null || symbol === void 0 ? void 0 : symbol.declarations) === null || _c === void 0 ? void 0 : _c[0])) {
            throw new errors_1.ParseError(`S119: Can't find function (${node.kind})`, node);
        }
        return parseActualFunction((_d = symbol.declarations) === null || _d === void 0 ? void 0 : _d[0], typeChecker);
    }
    if (typescript_1.default.isPropertyAccessExpression(node)) {
        const lastToken = node.getLastToken();
        if (lastToken) {
            return parseActualFunction(lastToken, typeChecker);
        }
    }
    throw new errors_1.ParseError(`S120: Unsupported syntax (${node.kind})`, node);
}
