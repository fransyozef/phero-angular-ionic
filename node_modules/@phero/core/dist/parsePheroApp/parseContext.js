"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseContext = void 0;
const typescript_1 = __importDefault(require("typescript"));
const generateParserModel_1 = __importStar(require("../code-gen/parsers/generateParserModel"));
const errors_1 = require("../errors");
const tsUtils_1 = require("../tsUtils");
function parseContext(serviceConfig, funcDefinitions, typeChecker) {
    if (!serviceConfig.middleware || serviceConfig.middleware.length === 0) {
        return [serviceConfig, funcDefinitions];
    }
    const ctxIO = getContextIO(serviceConfig.middleware, typeChecker);
    // HACK get the second param from the middleware func, this is always the contextParam
    const pheroContextType = serviceConfig.middleware[0]
        .middleware.parameters[1].type;
    const contextType = typescript_1.default.factory.createTypeReferenceNode(pheroContextType.typeName, [typescript_1.default.factory.createTypeLiteralNode(ctxIO.inputContextProps)]);
    return [
        { ...serviceConfig, contextType },
        funcDefinitions.map((func) => addFunctionContext(ctxIO, contextType, func, typeChecker)),
    ];
}
exports.parseContext = parseContext;
function addFunctionContext(ctxIO, contextType, func, typeChecker) {
    var _a;
    const ctxIndex = func.parameters.findIndex((p) => p.type &&
        typescript_1.default.isTypeReferenceNode(p.type) &&
        (0, tsUtils_1.getNameAsString)(p.type.typeName) === "PheroContext");
    if (ctxIndex === -1) {
        return {
            ...func,
            serviceContext: {
                type: contextType,
            },
        };
    }
    const ctxParam = func.parameters[ctxIndex];
    if (ctxIndex !== 0) {
        throw new errors_1.ParseError(`S105: PheroContext parameter should be the first parameter`, ctxParam);
    }
    const ctxParamType = ctxParam.type;
    if (!ctxParamType) {
        throw new errors_1.ParseError(`S106: PheroContext parameter should have a type declared`, ctxParam);
    }
    if (!typescript_1.default.isTypeReferenceNode(ctxParamType) ||
        ((_a = ctxParamType.typeArguments) === null || _a === void 0 ? void 0 : _a.length) !== 1) {
        throw new errors_1.ParseError(`S107: PheroContext parameter's type argument has an incorrect type`, ctxParam);
    }
    const funcCtx = ctxParamType.typeArguments[0];
    const funcCtxParserModel = getRootObjectParserModel(funcCtx, typeChecker);
    const funcCtxProps = getPropertySignatures(funcCtx);
    for (const funcCtxMemberParser of funcCtxParserModel.members) {
        if (funcCtxMemberParser.type !== generateParserModel_1.ParserModelType.Member) {
            throw new errors_1.ParseError(`S108: Context type can't have index members`, funcCtx);
        }
        const prop = funcCtxProps.find((p) => (0, tsUtils_1.getNameAsString)(p.name) === funcCtxMemberParser.name);
        if (!prop) {
            throw new errors_1.ParseError(`S109: Can't find property with name "${funcCtxMemberParser.name}"`, funcCtx);
        }
        const accumulatedContextMember = ctxIO.accumulatedContext.members.find((m) => m.type === generateParserModel_1.ParserModelType.Member &&
            m.name === funcCtxMemberParser.name);
        if (!accumulatedContextMember) {
            throw new errors_1.ParseError(`S110: Property should be provided by middleware`, prop);
        }
        if (!isSameMember(funcCtxMemberParser, accumulatedContextMember)) {
            throw new errors_1.ParseError(`S111: Context member "${funcCtxMemberParser.name}" would change type of already existing context member`, prop);
        }
    }
    return {
        ...func,
        serviceContext: {
            paramName: (0, tsUtils_1.getNameAsString)(ctxParam.name),
            type: contextType,
        },
    };
}
function getContextIO(middleware, typeChecker) {
    return middleware.reduce(({ inputContext, inputContextProps, accumulatedContext }, { contextType: ctxType, nextType }) => {
        if (ctxType) {
            const ctxParserModel = getRootObjectParserModel(ctxType, typeChecker);
            const ctxProps = getPropertySignatures(ctxType);
            for (const ctxMem of ctxParserModel.members) {
                if (ctxMem.type === generateParserModel_1.ParserModelType.Member) {
                    const accMemIndex = accumulatedContext.members.findIndex((accMem) => accMem.type === generateParserModel_1.ParserModelType.Member &&
                        accMem.name === ctxMem.name);
                    if (accMemIndex === -1) {
                        // NOTE we need the context from the client
                        inputContext.members.push(ctxMem);
                        const ctxProp = ctxProps.find((p) => (0, tsUtils_1.getNameAsString)(p.name) === ctxMem.name);
                        if (!ctxProp) {
                            throw new errors_1.ParseError(`S112: Can't find property with name "${ctxMem.name}"`, ctxType);
                        }
                        inputContextProps.push(ctxProp);
                        // we also accumlate it for use in other middleware or rpc
                        accumulatedContext.members.push(ctxMem);
                    }
                    else {
                        // lets check whether the user doesn't change already defined types of context
                        const accMem = accumulatedContext.members[accMemIndex];
                        if (accMem.type !== generateParserModel_1.ParserModelType.Member) {
                            throw new errors_1.ParseError(`S113: Context type can't have index members`, ctxType);
                        }
                        if (!isSameMember(ctxMem, accMem)) {
                            throw new errors_1.ParseError(`S114: Context member ${ctxMem.name} would change type of already existing context member`, ctxType);
                        }
                    }
                }
            }
        }
        if (nextType) {
            const nextParserModel = getRootObjectParserModel(nextType, typeChecker);
            for (const nxtMem of nextParserModel.members) {
                if (nxtMem.type === generateParserModel_1.ParserModelType.Member) {
                    const accMemIndex = accumulatedContext.members.findIndex((accMem) => accMem.type === generateParserModel_1.ParserModelType.Member &&
                        accMem.name === nxtMem.name);
                    if (accMemIndex === -1) {
                        accumulatedContext.members.push(nxtMem);
                    }
                    else {
                        // NOTE overwrite with the new parser
                        accumulatedContext.members[accMemIndex] = nxtMem;
                    }
                }
            }
        }
        return {
            inputContext,
            inputContextProps,
            accumulatedContext,
        };
    }, {
        inputContext: {
            type: generateParserModel_1.ParserModelType.Object,
            members: [],
        },
        inputContextProps: [],
        accumulatedContext: {
            type: generateParserModel_1.ParserModelType.Object,
            members: [],
        },
    });
}
function getRootObjectParserModel(typeNode, typeChecker) {
    const nextParserModel = (0, generateParserModel_1.default)(typeChecker, getDeclaredNode(typeNode, typeChecker), "root");
    if (nextParserModel.parser.type !== generateParserModel_1.ParserModelType.Object) {
        throw new errors_1.ParseError("S115: Should be an object type", typeNode);
    }
    return nextParserModel.parser;
}
function getDeclaredNode(typeNode, typeChecker) {
    var _a, _b;
    if (typescript_1.default.isTypeReferenceNode(typeNode)) {
        const type = typeChecker.getTypeFromTypeNode(typeNode);
        const symbol = (_a = type.aliasSymbol) !== null && _a !== void 0 ? _a : type.symbol;
        if ((_b = symbol.declarations) === null || _b === void 0 ? void 0 : _b.length) {
            return symbol.declarations[0];
        }
    }
    return typeNode;
}
function getPropertySignatures(typeNode) {
    if (typescript_1.default.isInterfaceDeclaration(typeNode)) {
        return typeNode.members.filter(typescript_1.default.isPropertySignature);
    }
    if (typescript_1.default.isTypeAliasDeclaration(typeNode)) {
        return getPropertySignatures(typeNode.type);
    }
    if (typescript_1.default.isTypeLiteralNode(typeNode)) {
        return typeNode.members.filter(typescript_1.default.isPropertySignature);
    }
    return [];
}
function isSameMember(left, right) {
    return JSON.stringify(left) === JSON.stringify(right);
}
