"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ReferenceMaker = exports.generateErrorClass = exports.generateModel = exports.generateClientFunction = exports.generateFunction = exports.generateNamespace = void 0;
const typescript_1 = __importDefault(require("typescript"));
const generateParser_1 = require("./code-gen/parsers/generateParser");
const generateParserFromModel_1 = __importDefault(require("./code-gen/parsers/generateParserFromModel"));
const generateParserModel_1 = __importDefault(require("./code-gen/parsers/generateParserModel"));
const errors_1 = require("./errors");
const parseAppDeclaration_1 = require("./parseAppDeclaration");
const parseReturnType_1 = __importDefault(require("./parsePheroApp/parseReturnType"));
const tsUtils_1 = require("./tsUtils");
const tsx = __importStar(require("./tsx"));
const exportModifier = typescript_1.default.factory.createModifier(typescript_1.default.SyntaxKind.ExportKeyword);
const asyncModifier = typescript_1.default.factory.createModifier(typescript_1.default.SyntaxKind.AsyncKeyword);
function generateNamespace(name, body) {
    return typescript_1.default.factory.createModuleDeclaration([exportModifier], name, typescript_1.default.factory.createModuleBlock(body), typescript_1.default.NodeFlags.Namespace);
}
exports.generateNamespace = generateNamespace;
function generateFunction(func, refMaker) {
    return typescript_1.default.factory.createFunctionDeclaration([exportModifier, asyncModifier], undefined, // asteriks is prohibited
    func.name, undefined, // typeParameters are prohibited
    generateFunctionParameters(func, refMaker), typescript_1.default.factory.createTypeReferenceNode("Promise", [
        generateTypeNode(func.returnType, refMaker),
    ]), undefined);
}
exports.generateFunction = generateFunction;
function generateFunctionParameters(func, refMaker) {
    var _a, _b;
    const parameters = ((_a = func.serviceContext) === null || _a === void 0 ? void 0 : _a.paramName)
        ? func.parameters.slice(1)
        : func.parameters;
    const result = parameters.map((param) => {
        if (!param.type) {
            throw new errors_1.ParseError(`S100: Parameter of your functions should have a type`, param);
        }
        return typescript_1.default.factory.createParameterDeclaration(param.modifiers, param.dotDotDotToken, param.name, param.questionToken, generateTypeNode(param.type, refMaker), undefined);
    });
    if (func.serviceContext) {
        return [
            // Note: we need to pass the context parameter as the first argument because we can
            // have optional parameters
            typescript_1.default.factory.createParameterDeclaration(undefined, undefined, (_b = func.serviceContext.paramName) !== null && _b !== void 0 ? _b : "context", undefined, generateTypeNode(func.serviceContext.type, refMaker), undefined),
            ...result,
        ];
    }
    return result;
}
function generateClientFunction(serviceName, contextType, func, refMaker, typeChecker) {
    let parameters = func.parameters.map((p) => typescript_1.default.factory.createParameterDeclaration(p.modifiers, p.dotDotDotToken, p.name, p.questionToken, p.type && generateTypeNode(p.type, refMaker), undefined));
    let context;
    if (contextType) {
        const firstParam = func.parameters[0];
        if (isParamPheroContextParam(firstParam)) {
            // skip first parameter if we have a context param
            parameters = parameters.slice(1);
            context = {
                name: (0, tsUtils_1.getNameAsString)(firstParam.name),
                type: contextType,
            };
        }
    }
    if (!func.name) {
        throw new errors_1.ParseError("Func must have name", func);
    }
    return typescript_1.default.factory.createPropertyAssignment(func.name, typescript_1.default.factory.createArrowFunction([typescript_1.default.factory.createModifier(typescript_1.default.SyntaxKind.AsyncKeyword)], undefined, parameters, func.type && generateTypeNode(func.type, refMaker), undefined, generateClientFunctionBlock(serviceName, context, func, refMaker, typeChecker)));
}
exports.generateClientFunction = generateClientFunction;
function isParamPheroContextParam(param) {
    return (!!param &&
        !!param.type &&
        typescript_1.default.isTypeReferenceNode(param.type) &&
        (0, tsUtils_1.getNameAsString)(param.type.typeName) === "PheroContext");
}
function generateClientFunctionBlock(serviceName, context, func, refMaker, typeChecker) {
    const returnType = (0, parseReturnType_1.default)(func);
    const isVoid = returnType.kind === typescript_1.default.SyntaxKind.VoidKeyword;
    const returnTypeNode = generateTypeNode(returnType, refMaker);
    if (!func.name) {
        throw new errors_1.ParseError("Func must have name", func);
    }
    return tsx.block(tsx.statement.return(tsx.expression.call(tsx.expression.propertyAccess(typescript_1.default.factory.createThis(), isVoid ? "requestVoid" : "request"), {
        typeArgs: isVoid ? undefined : [returnTypeNode],
        args: [
            tsx.literal.string(serviceName),
            tsx.literal.string(func.name.getText()),
            tsx.literal.object(...func.parameters.map((p, i) => {
                if (!typescript_1.default.isIdentifier(p.name)) {
                    // TODO https://trello.com/c/UJHzzAHz/25-support-object-array-binding-patterns-in-parameter-names
                    throw new errors_1.ParseError("S133: No support for prop binding names yet", p.name);
                }
                if (context && i === 0) {
                    return tsx.property.assignment(context.name, tsx.expression.await(tsx.expression.call(tsx.expression.propertyAccess(typescript_1.default.factory.createThis(), "opts", "context", serviceName))));
                }
                return tsx.property.shorthandAssignment(p.name.getText());
            })),
            `error_parser_${serviceName}`,
            ...(isVoid
                ? []
                : [
                    makeReferenceToParserFunction(returnType, returnTypeNode, refMaker, typeChecker),
                ]),
        ],
    })));
}
function generateModel(model, refMaker) {
    var _a, _b, _c;
    if (typescript_1.default.isTypeAliasDeclaration(model)) {
        return typescript_1.default.factory.createTypeAliasDeclaration([exportModifier], model.name, (_a = model.typeParameters) === null || _a === void 0 ? void 0 : _a.map((tp) => typescript_1.default.factory.createTypeParameterDeclaration(undefined, tp.name, tp.constraint && generateTypeNode(tp.constraint, refMaker), tp.default && generateTypeNode(tp.default, refMaker))), generateTypeNode(model.type, refMaker));
    }
    else if (typescript_1.default.isInterfaceDeclaration(model)) {
        return typescript_1.default.factory.createInterfaceDeclaration([exportModifier], model.name, (_b = model.typeParameters) === null || _b === void 0 ? void 0 : _b.map((tp) => typescript_1.default.factory.createTypeParameterDeclaration(undefined, tp.name, tp.constraint && generateTypeNode(tp.constraint, refMaker), tp.default && generateTypeNode(tp.default, refMaker))), (_c = model.heritageClauses) === null || _c === void 0 ? void 0 : _c.map((hc) => typescript_1.default.factory.createHeritageClause(hc.token, hc.types.map((t) => {
            var _a;
            return typescript_1.default.factory.createExpressionWithTypeArguments(typescript_1.default.isIdentifier(t.expression)
                ? refMaker.fromIdentifier(t.expression)
                : typescript_1.default.isPropertyAccessExpression(t.expression) &&
                    typescript_1.default.isIdentifier(t.expression.name)
                    ? refMaker.fromIdentifier(t.expression.name)
                    : t.expression, (_a = t.typeArguments) === null || _a === void 0 ? void 0 : _a.map((t) => generateTypeNode(t, refMaker)));
        }))), model.members.map((m) => generateTypeElement(m, refMaker)));
    }
    else if (typescript_1.default.isEnumDeclaration(model)) {
        return typescript_1.default.factory.createEnumDeclaration([exportModifier], model.name, model.members.map((member) => {
            return typescript_1.default.factory.createEnumMember(generatePropertyName(member.name), member.initializer &&
                (typescript_1.default.isStringLiteral(member.initializer)
                    ? typescript_1.default.factory.createStringLiteral(member.initializer.text)
                    : typescript_1.default.isNumericLiteral(member.initializer)
                        ? typescript_1.default.factory.createNumericLiteral(member.initializer.text)
                        : undefined));
        }));
    }
    return model;
}
exports.generateModel = generateModel;
function generateErrorClass(error, refMaker) {
    return tsx.classDeclaration({
        name: error.name,
        extendsType: typescript_1.default.factory.createExpressionWithTypeArguments(tsx.expression.identifier("Error"), undefined),
        export: true,
        constructor: tsx.constructor({
            params: error.properties.map((prop) => tsx.param({
                public: true,
                readonly: true,
                name: prop.name,
                type: generateTypeNode(prop.type, refMaker),
            })),
        }),
    });
}
exports.generateErrorClass = generateErrorClass;
function generatePropertyName(propName) {
    if (typescript_1.default.isIdentifier(propName)) {
        return typescript_1.default.factory.createIdentifier(propName.text);
    }
    else if (typescript_1.default.isStringLiteral(propName)) {
        return typescript_1.default.factory.createStringLiteral(propName.text);
    }
    else if (typescript_1.default.isNumericLiteral(propName)) {
        return typescript_1.default.factory.createNumericLiteral(propName.text);
    }
    // else if (ts.isComputedPropertyName(propName)) {
    // } else if (ts.isPrivateIdentifier(propName)) {
    // }
    throw new errors_1.ParseError("S101: We currently do not support these kind of property names", propName);
}
function generateTypeElement(typeElement, refMaker) {
    if (typescript_1.default.isPropertySignature(typeElement)) {
        return typescript_1.default.factory.createPropertySignature(typeElement.modifiers, typeElement.name, typeElement.questionToken, typeElement.type && generateTypeNode(typeElement.type, refMaker));
    }
    if (typescript_1.default.isIndexSignatureDeclaration(typeElement)) {
        return typescript_1.default.factory.createIndexSignature(typeElement.modifiers, typeElement.parameters.map((p) => typescript_1.default.factory.createParameterDeclaration(p.modifiers, p.dotDotDotToken, p.name, p.questionToken, p.type && generateTypeNode(p.type, refMaker), p.initializer)), generateTypeNode(typeElement.type, refMaker));
    }
    throw new errors_1.ParseError(`S102: We currently do not support this syntax (${typeElement.kind})`, typeElement);
}
function makeReferenceToParserFunction(typeNode, returnTypeNode, refMaker, typeChecker) {
    return tsx.arrowFunction({
        params: [tsx.param({ name: "data", type: tsx.type.any })],
        returnType: tsx.type.reference({
            name: "ParseResult",
            args: [returnTypeNode],
        }),
        body: (0, generateParser_1.generateParserBody)(returnTypeNode, (0, generateParserFromModel_1.default)((0, generateParserModel_1.default)(typeChecker, typeNode, "data"))),
    });
}
function generateTypeNode(type, refMaker) {
    var _a;
    if (typescript_1.default.isTypeReferenceNode(type)) {
        return typescript_1.default.factory.createTypeReferenceNode(refMaker.fromTypeNode(type), (_a = type.typeArguments) === null || _a === void 0 ? void 0 : _a.map((t) => generateTypeNode(t, refMaker)));
    }
    if (typescript_1.default.isLiteralTypeNode(type)) {
        if (typescript_1.default.isStringLiteral(type.literal)) {
            return typescript_1.default.factory.createLiteralTypeNode(typescript_1.default.factory.createStringLiteral(type.literal.text));
        }
        else if (typescript_1.default.isNumericLiteral(type.literal)) {
            return typescript_1.default.factory.createLiteralTypeNode(typescript_1.default.factory.createNumericLiteral(type.literal.text));
        }
    }
    if (typescript_1.default.isUnionTypeNode(type)) {
        return typescript_1.default.factory.createUnionTypeNode(type.types.map((t) => generateTypeNode(t, refMaker)));
    }
    if (typescript_1.default.isIntersectionTypeNode(type)) {
        return typescript_1.default.factory.createIntersectionTypeNode(type.types.map((t) => generateTypeNode(t, refMaker)));
    }
    if (typescript_1.default.isTypeLiteralNode(type)) {
        return typescript_1.default.factory.createTypeLiteralNode(type.members.map((m) => generateTypeElement(m, refMaker)));
    }
    if (typescript_1.default.isArrayTypeNode(type)) {
        return typescript_1.default.factory.createArrayTypeNode(generateTypeNode(type.elementType, refMaker));
    }
    if (typescript_1.default.isIndexedAccessTypeNode(type)) {
        return typescript_1.default.factory.createIndexedAccessTypeNode(generateTypeNode(type.objectType, refMaker), generateTypeNode(type.indexType, refMaker));
    }
    if (typescript_1.default.isTupleTypeNode(type)) {
        return typescript_1.default.factory.createTupleTypeNode(type.elements.map((el) => generateTypeNode(el, refMaker)));
    }
    return type;
}
function cleanTypeName(tn, typeChecker) {
    if (typescript_1.default.isIdentifier(tn)) {
        return tn;
    }
    const symbol = typeChecker.getSymbolAtLocation(tn);
    if (!symbol ||
        (symbol.flags & typescript_1.default.SymbolFlags.EnumMember) !== typescript_1.default.SymbolFlags.EnumMember) {
        return tn.right;
    }
    if (typescript_1.default.isIdentifier(tn.left)) {
        return tn;
    }
    return typescript_1.default.factory.createQualifiedName(tn.left.right, // Enum
    tn.right);
}
function unpack(entityName) {
    return typescript_1.default.isIdentifier(entityName)
        ? [entityName]
        : [...unpack(entityName.left), entityName.right];
}
function combineAsEntityName(ids) {
    if (ids.length === 1) {
        return ids[0];
    }
    const rest = ids.slice(0, ids.length - 1);
    const last = ids[ids.length - 1];
    return typescript_1.default.factory.createQualifiedName(combineAsEntityName(rest), last);
}
function combineAsExpr(ids) {
    if (ids.length === 1) {
        return ids[0];
    }
    const rest = ids.slice(0, ids.length - 1);
    const last = ids[ids.length - 1];
    return typescript_1.default.factory.createPropertyAccessExpression(combineAsExpr(rest), last);
}
class ReferenceMaker {
    constructor(domain, typeChecker, sharedDomainName) {
        this.domain = domain;
        this.typeChecker = typeChecker;
        this.sharedDomainName = sharedDomainName;
    }
    fromTypeNode(typeNode) {
        var _a;
        if (typeNode.typeName.getText() === "PheroContext") {
            return typescript_1.default.factory.createIdentifier("phero.PheroContext");
        }
        const symbol = this.typeChecker.getSymbolAtLocation(typeNode.typeName);
        const declr = (_a = symbol === null || symbol === void 0 ? void 0 : symbol.declarations) === null || _a === void 0 ? void 0 : _a[0];
        if (declr) {
            if ((0, parseAppDeclaration_1.isModel)(declr) && this.domain.includes(declr)) {
                return combineAsEntityName([
                    ...(this.sharedDomainName ? [this.sharedDomainName] : []),
                    cleanTypeName(typeNode.typeName, this.typeChecker),
                ].flatMap(unpack));
            }
            if (typescript_1.default.isImportSpecifier(declr)) {
                return combineAsEntityName([
                    ...(this.sharedDomainName ? [this.sharedDomainName] : []),
                    cleanTypeName(declr.name, this.typeChecker),
                ].flatMap(unpack));
            }
        }
        return typeNode.typeName;
    }
    fromIdentifier(identifier) {
        var _a;
        if (identifier.text === "PheroContext") {
            return typescript_1.default.factory.createIdentifier("phero.PheroContext");
        }
        const symbol = this.typeChecker.getSymbolAtLocation(identifier);
        const declr = (_a = symbol === null || symbol === void 0 ? void 0 : symbol.declarations) === null || _a === void 0 ? void 0 : _a[0];
        if (declr) {
            if ((0, parseAppDeclaration_1.isModel)(declr) && this.domain.includes(declr)) {
                return combineAsExpr([
                    ...(this.sharedDomainName ? [this.sharedDomainName] : []),
                    cleanTypeName(identifier, this.typeChecker),
                ].flatMap(unpack));
            }
            if (typescript_1.default.isImportSpecifier(declr)) {
                return combineAsExpr([
                    ...(this.sharedDomainName ? [this.sharedDomainName] : []),
                    cleanTypeName(declr.name, this.typeChecker),
                ].flatMap(unpack));
            }
        }
        return identifier;
    }
}
exports.ReferenceMaker = ReferenceMaker;
